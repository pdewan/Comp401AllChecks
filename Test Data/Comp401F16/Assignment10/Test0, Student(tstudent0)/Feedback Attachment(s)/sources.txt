//START OF FILE: src/grail/singletonscreator.java
package grail;

import java.beans.PropertyChangeListener;

import grail.collections.MyTable;
import grail.graphics.BridgeScene;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandInterpreterInterface;
import grail.interfaces.ScannerBeanInterface;
import grail.interfaces.Table;
import grail.interfaces.mvc.BridgeSceneControllerInterface;
import grail.interfaces.mvc.CommandInterpreterControllerInterface;
import grail.interfaces.mvc.CommandInterpreterViewInterface;
import grail.interfaces.mvc.DelegatingBridgeSceneViewInterface;
import grail.interfaces.mvc.PaintingViewMaster;
import grail.mvc.controller.BridgeSceneController;
import grail.mvc.controller.CommandInterpreterController;
import grail.mvc.view.CommandInterpreterView;
import grail.mvc.view.ConsoleSceneView;
import grail.mvc.view.DelegatingBridgeSceneView;
import grail.mvc.view.ObservableBridgeScenePainter;
import grail.scanner.CommandInterpreter;
import grail.scanner.ScannerBean;
import util.annotations.Tags;

@Tags({"SingletonsCreator"})
public class SingletonsCreator {
	
	private static ScannerBeanInterface scannerBean = null;
	private static BridgeSceneInterface bridgeScene = null;
	private static Table avatarTable = null;
	private static CommandInterpreterInterface commandInterpreter = null;
	private static PropertyChangeListener consoleSceneView = null;
	private static PaintingViewMaster painter = null;
	private static DelegatingBridgeSceneViewInterface view = null;
	private static BridgeSceneControllerInterface mainControl = null;
	private static CommandInterpreterControllerInterface interpreterController = null;
	private static CommandInterpreterViewInterface interpreterView = null;
	
	
	@Tags({"commandInterpreterViewFactoryMethod"})
	public static CommandInterpreterViewInterface commandInterpreterViewFactoryMethod(){
		if (null == interpreterView){
			interpreterView = new CommandInterpreterView();
		}
		return interpreterView;
	}
	
	@Tags({"commandInterpreterControllerFactoryMethod"})
	public static CommandInterpreterControllerInterface commandInterpreterControllerFactoryMethod(){
		if (null == interpreterController){
			interpreterController = new CommandInterpreterController(commandInterpreterViewFactoryMethod());
		}
		return interpreterController;
	}
	
	@Tags({"bridgeSceneControllerFactoryMethod"})
	public static BridgeSceneControllerInterface bridgeSceneControllerFactoryMethod(){
		if (null == mainControl){
			mainControl = new BridgeSceneController(observableBridgeScenePainterFactoryMethod());
		}
		return mainControl;
	}
	
	@Tags({"observableBridgeScenePainterFactoryMethod"})
	public static PaintingViewMaster observableBridgeScenePainterFactoryMethod(){
		if (null == painter){
			painter = new ObservableBridgeScenePainter();
		}
		return painter;
	}
	
	@Tags({"delegatingBridgeSceneViewFactoryMethod"})
	public static DelegatingBridgeSceneViewInterface delegatingBridgeSceneViewFactoryMethod(){
		if (null == view){
			view = new DelegatingBridgeSceneView(bridgeSceneFactoryMethod());
		}
		return view;
	}
	
	@Tags({"scannerFactoryMethod"})
	public static ScannerBeanInterface scannerFactoryMethod(){
		if (null == scannerBean){
			scannerBean = new ScannerBean();
		}
		return scannerBean;
	}
	
	@Tags({"bridgeSceneFactoryMethod"})
	public static BridgeSceneInterface bridgeSceneFactoryMethod(){
		if (null == bridgeScene){
			bridgeScene = new BridgeScene();
		}
		return bridgeScene;
	}
	
	// Side effect: creates a BridgeScene
	@Tags({"avatarTableFactoryMethod"})
	public static Table avatarTableFactoryMethod(){
		if (null == avatarTable){
			avatarTable = new MyTable();
			
			// Create a scene if needed
			bridgeSceneFactoryMethod();	//return value not needed
			
			// Populate table
			avatarTable.put("arthur", bridgeScene.getArthur());
			avatarTable.put("galahad", bridgeScene.getGalahad());
			avatarTable.put("lancelot", bridgeScene.getLancelot());
			avatarTable.put("robin", bridgeScene.getRobin());
			avatarTable.put("guard", bridgeScene.getGuard());
		}
		return avatarTable;
	}
	
	// Side effect: creates a BridgeScene and ScannerBean
	@Tags({"commandInterpreterFactoryMethod"})
	public static CommandInterpreterInterface commandInterpreterFactoryMethod(){
		if (null == commandInterpreter){
			bridgeSceneFactoryMethod();
			scannerFactoryMethod();
			
			commandInterpreter = new CommandInterpreter(bridgeScene, scannerBean);
		}
		return commandInterpreter;
	}
	
	@Tags({"consoleSceneViewFactoryMethod"})
	public static PropertyChangeListener consoleSceneViewFactoryMethod(){
		if (null == consoleSceneView){
			consoleSceneView = new ConsoleSceneView();
		}
		return consoleSceneView;
	}
}
//END OF FILE
//START OF FILE: src/grail/animations/animatingcommand.java
package grail.animations;

import grail.interfaces.AnimatorInterface;
import grail.interfaces.AvatarInterface;
import grail.interfaces.CommandThread;
import util.annotations.Tags;

@Tags({"AnimatingCommand"})
public class AnimatingCommand implements CommandThread{

	private AnimatorInterface animator;
	AvatarInterface avatar;
	
	public AnimatingCommand(AnimatorInterface animator, AvatarInterface avatar){
		this.animator = animator;
		this.avatar = avatar;
	}

	@Override
	public void run() {
		animator.animateAvatar(avatar);
	}

}
//END OF FILE
//START OF FILE: src/grail/animations/animator.java
package grail.animations;

import grail.interfaces.AnimatorInterface;
import grail.interfaces.AvatarInterface;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.RotatingLineInterface;
import util.annotations.Tags;
import util.misc.ThreadSupport;


@Tags({"Animator"})
public class Animator implements AnimatorInterface {

	private static final int NUM_FRAMES = 45;
	private static final int DEGREES_PER_ROTATE = 2;
	private static final int ROTATE_DELAY = 20;
	
	private static final int CLAP_DELAY = 1000;
	private static final double CLAP_ANGLE = Math.PI / 2;
	
	// Empty constructor
	public Animator() {}

	@Override
	@Tags({"animateAvatar"})
	public void animateAvatar(AvatarInterface avatar) {
		// Arm up
		for (int i = 0; i < NUM_FRAMES; ++i){
			avatar.getArms().getRightLine().rotateByClockwiseDegrees(-DEGREES_PER_ROTATE);
			ThreadSupport.sleep(ROTATE_DELAY);
		}
		// Arm down
		for (int i = 0; i < NUM_FRAMES; ++i){
			avatar.getArms().getRightLine().rotateByClockwiseDegrees(DEGREES_PER_ROTATE);
			ThreadSupport.sleep(ROTATE_DELAY);
		}
	}

	@Override
	public void clapGuard(BridgeSceneInterface scene) {
		RotatingLineInterface leftArm = scene.getGuard().getArms().getLeftLine();
		RotatingLineInterface rightArm = scene.getGuard().getArms().getRightLine();
		
		double oldLeftAngle = leftArm.getAngle();
		double oldRightAngle = rightArm.getAngle();
		leftArm.setAngle(CLAP_ANGLE);
		rightArm.setAngle(CLAP_ANGLE);
		
		ThreadSupport.sleep(CLAP_DELAY);
		
		leftArm.setAngle(oldLeftAngle);
		rightArm.setAngle(oldRightAngle);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/animations/clapcommand.java
package grail.animations;

import grail.interfaces.AnimatorInterface;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandThread;

public class ClapCommand implements CommandThread{

	AnimatorInterface animator;
	BridgeSceneInterface scene;
	
	public ClapCommand(AnimatorInterface animator, BridgeSceneInterface scene){
		this.animator = animator;
		this.scene = scene;
	}
	
	@Override
	public void run() {
		animator.clapGuard(scene);
	}

}
//END OF FILE
//START OF FILE: src/grail/collections/abasehistory.java
package grail.collections;

import grail.interfaces.BaseHistory;
import grail.interfaces.Token;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.VECTOR_PATTERN)
public class ABaseHistory implements BaseHistory {
	
	
	//This collection has a fixed maximum size.
	public static final int MAX_SIZE = 50;
	

	// The underlying array to store the elements
	protected Token[] contents = new Token[MAX_SIZE];
	
	// number of filled elements
	protected int size = 0;	// number of filled elements (protected access)
	
	// Number of filled elements
	@Override
	public int size() {
		return size;
	}
	
	@Override
	public Token elementAt (int index) {
		return contents[index];
	}

	protected boolean isFull() {
		return size == MAX_SIZE;
	}
	
	@Override
	public void addElement(Token element) {
		if (isFull()) {
			System.out.println("Cannot add item to a full history");
		} else {
			contents[size] = element;
			size++;
		}
	} 	
	
}
//END OF FILE
//START OF FILE: src/grail/collections/clearablehistory.java
package grail.collections;

import grail.interfaces.ClearableHistoryInterface;
import grail.interfaces.Token;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@StructurePattern(StructurePatternNames.VECTOR_PATTERN)
@Tags({"ClearableHistory"})
public class ClearableHistory extends ABaseHistory implements ClearableHistoryInterface {

	@Override
	public void clear(){
		size = 0;
		contents = new Token[MAX_SIZE];
	}
}
//END OF FILE
//START OF FILE: src/grail/collections/mytable.java
package grail.collections;

import java.util.ArrayList;
import java.util.List;

import grail.interfaces.Table;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@StructurePattern(StructurePatternNames.MAP_PATTERN)
@Tags({"Table"})
public class MyTable implements Table {
	
	private List<String> keys = new ArrayList<String>();
	private List<Object> values = new ArrayList<Object>();
	
	@Override
	public void put (String key, Object val){
		if (null == key || null == val){
			return;
		}
		
		int index = keys.indexOf(key);
		
		// If the element was not found, add to both columns
		if (index < 0){
			keys.add(key);
			values.add(val);
		
		// Otherwise update second column
		}else{
			values.set(index, val);
		}
		
	}
	
	@Override
	public Object get (String key){
		int index = keys.indexOf(key);
		
		// If not found
		if (index < 0){
			return null;
		
		}else{
			return values.get(index);
		}
	}
	
}//end class
//END OF FILE
//START OF FILE: src/grail/graphics/avatar.java
package grail.graphics;

import java.beans.PropertyChangeListener;

import grail.interfaces.AvatarInterface;
import grail.interfaces.ImageInterface;
import grail.interfaces.RotatingLineInterface;
import grail.interfaces.StringShapeInterface;
import grail.interfaces.VShapeInterface;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;
import util.annotations.Visible;

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@Tags({"Avatar"})
@PropertyNames({"X", "Y","Head", "Legs", "Arms", "Torso", "StringShape"})
@EditablePropertyNames({"X", "Y"})
public class Avatar extends LocatableObject implements AvatarInterface {
	
	// The anchor (avatar location) is the spot between the avatar's feet when the
	// avatar is first created. This is the distance from waist to that point.
	private int floorToWaist;
	
	private static final double TORSO_LENGTH = 80;
	private static final double ARMS_LENGTH = 80;
	private static final double LEGS_LENGTH = 80;
	private static final double TORSO_ANGLE = Math.PI/2;
	
	private ImageInterface head;
	private VShapeInterface legs;
	private VShapeInterface arms;
	private RotatingLineInterface torso;
	private StringShapeInterface stringShape;
	
	public Avatar(ImageInterface head){
		this.head = head;
		
		// Construct other parts
		torso = new RotatingLine(0, 0, TORSO_LENGTH, TORSO_ANGLE);
		arms = new VShape(0, 0, ARMS_LENGTH);
		legs = new VShape(0, 0, LEGS_LENGTH);
		stringShape = new StringShape(0, 0, "");
		
		floorToWaist = legs.getRightLine().getHeight();
		
		// Figure out the postion of the avatar anchor
		int xPos = head.getX() + (head.getWidth()/2);
		int yPos = (int)(head.getY() + head.getHeight()
						+ torso.getRadius() 
						+ floorToWaist);	
		
		// Use setters to build character
		setX(xPos);
		setY(yPos);
	}
	
	public Avatar(int xPos, int yPos, String imageFileName){
		// Construct parts
		head = new Image(0, 0, imageFileName);
		torso = new RotatingLine(0, 0, TORSO_LENGTH, TORSO_ANGLE);
		arms = new VShape(0, 0, ARMS_LENGTH);
		legs = new VShape(0, 0, LEGS_LENGTH);
		stringShape = new StringShape(0, 0, "");
		
		// Use setters to build character
		setX(xPos);
		setY(yPos);
	}
	
	@Visible(false)
	@Override
	public void setX(int newX) {
		
		super.setX(newX);
		
		// Place the character:
		// Since character is upright, everything is already
		// centered except the head and utterance
		legs.setX(newX);
		torso.setX(newX);
		arms.setX(newX);
		
		head.setX(newX-(head.getWidth())/2);
		stringShape.setX(head.getX() + head.getWidth());
	}
	
	@Visible(false)
	@Override
	public void setY(int newY) {
		
		super.setY(newY);
		
		// Place the character:
		legs.setY(newY-floorToWaist);
		
		int torsoTop = legs.getY()-torso.getHeight();
		torso.setY(torsoTop);
		arms.setY(torsoTop);
		
		// Head anchor is at its top, so adjust
		head.setY(torsoTop - head.getHeight());
		
		stringShape.setY(head.getY());
	}

	@Override
	public StringShapeInterface getStringShape() {
		return stringShape;
	}

	@Override
	public ImageInterface getHead() {
		return head;
	}

	@Override
	public VShapeInterface getArms() {
		return arms;
	}

	@Override
	public VShapeInterface getLegs() {
		return legs;
	}

	@Override
	public RotatingLineInterface getTorso() {
		return torso;
	}

	@Tags({"move"})
	@Override
	public void move(int changeInX, int changeInY) {
		setX(getX()+changeInX);
		setY(getY()+changeInY);
	}

	@Tags({"scale"})
	@Override
	public void scale(double scalar) {
		
		// Ceiling necessary because otherwise small changes are not visible
		head.setHeight((int)Math.ceil(head.getHeight() * scalar));
		head.setWidth((int)Math.ceil(head.getWidth()*scalar));
		
		legs.setLinesLength(legs.getLinesLength() * scalar);
		arms.setLinesLength(arms.getLinesLength() * scalar);
		torso.setRadius(torso.getRadius() * scalar);
		
		// Use setters to reconstruct body
		setX(getX());
		setY(getY());
	}
	
	@Override
	public void addPropertyChangeListenerToAtomics(PropertyChangeListener listener){
		getArms().addPropertyChangeListenerToAtomics(listener);
		getLegs().addPropertyChangeListenerToAtomics(listener);
		getHead().addPropertyChangeListener(listener);
		getStringShape().addPropertyChangeListener(listener);
		getTorso().addPropertyChangeListener(listener);
	}
}
//END OF FILE
//START OF FILE: src/grail/graphics/boundedshape.java
package grail.graphics;

import java.beans.PropertyChangeEvent;

import grail.interfaces.BoundedShapeInterface;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"X", "Y", "Width", "Height"})
@EditablePropertyNames({"X", "Y", "Width", "Height"})
@Tags({"BoundedShape"})
public class BoundedShape extends ObservableLocatableObject implements BoundedShapeInterface {

	private int width;
	private int height;
	
	public BoundedShape (int xPos, int yPos, int width, int height){
		super (xPos,yPos);
		this.width = width;
		this.height = height;
	}
	
	// empty constructor
	public BoundedShape(){}
	
	@Override
	public void setWidth(int newWidth) {
		int oldWidth = width;
		width = newWidth;
		notifyAllListeners(new PropertyChangeEvent(this, "Width", oldWidth, newWidth));
	}

	@Override
	public int getWidth() {
		return width;
	}

	@Override
	public void setHeight(int newHeight) {
		int oldHeight = height;
		height = newHeight;
		notifyAllListeners(new PropertyChangeEvent(this, "Height", oldHeight, newHeight));
	}

	@Override
	public int getHeight() {
		return height;
	}

	@Override
	@Tags({"move"})
	public void move(int moveX, int moveY) {
		setX(getX() + moveX);
		setY(getY() + moveY);
	}

}
//END OF FILE
//START OF FILE: src/grail/graphics/bridgescene.java
package grail.graphics;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.List;

import grail.interfaces.AvatarInterface;
import grail.interfaces.BoundedShapeInterface;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.GorgeWithBridgeInterface;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@Tags({"BridgeScene"})
@PropertyNames({"Guard", "Arthur", "Lancelot","Robin", "Galahad",
	"Gorge", "GuardArea", "KnightArea", "Occupied", "KnightTurn"})
public class BridgeScene implements BridgeSceneInterface {

	private static final String EMPTY_STRING = "";
	
	private static final int ARTHUR_LOCATION_X = 100;
	private static final int ARTHUR_LOCATION_Y = 300;
	private static final int LANCELOT_LOCATION_X = 200;
	private static final int LANCELOT_LOCATION_Y = 300;
	private static final int ROBIN_LOCATION_X = 300;
	private static final int ROBIN_LOCATION_Y = 300;
	private static final int GALAHAD_LOCATION_X = 400;
	private static final int GALAHAD_LOCATION_Y = 300;
	private static final int GUARD_LOCATION_X = 750;
	private static final int GUARD_LOCATION_Y = 300;
	
	private static final int GORGE_LEFT_X = 850;
	private static final int GORGE_RIGHT_X = 1050;
	private static final int BRIDGE_WIDTH = 50;
	private static final int BRIDGE_Y = 275;
	
	private static final int KNIGHT_AREA_X = 500;
	private static final int KNIGHT_AREA_Y = 250;
	private static final int GUARD_AREA_X = 700;
	private static final int GUARD_AREA_Y = 250;
	
	private static final int AREA_DIAMETERS = 100;
	
	private static final int PASS_DESTINATION_X = GORGE_RIGHT_X + 100;
	private static final int FAIL_DESTINATION_X = (GORGE_LEFT_X + GORGE_RIGHT_X)/2;
	private static final int FAIL_DESTINATION_Y = BRIDGE_Y + 300;
	
	private static final String ARTHUR_FILE_LOCATION = "images/arthur.jpg";
	private static final String LANCELOT_FILE_LOCATION = "images/lancelot.jpg";
	private static final String ROBIN_FILE_LOCATION = "images/robin.jpg";
	private static final String GALAHAD_FILE_LOCATION = "images/galahad.jpg";
	private static final String GUARD_FILE_LOCATION = "images/guard.jpg";
	
	private static final String PRECONDITION_PROPERTY = "this";
	private static final String APPROACH_METHOD_TAG = "approach";
	private static final String SAY_METHOD_TAG = "say";
	private static final String PASSED_METHOD_TAG = "passed";
	private static final String FAILED_METHOD_TAG = "failed";
	
	private AvatarInterface arthur;
	private AvatarInterface lancelot;
	private AvatarInterface robin;
	private AvatarInterface galahad;
	private AvatarInterface guard;
	
	private AvatarInterface occupyingKnight;
	
	private GorgeWithBridgeInterface gorge;
	private BoundedShapeInterface knightArea;
	private BoundedShapeInterface guardArea;
	
	private boolean occupied;
	private boolean knightTurn;
	
	private List<PropertyChangeListener> listeners = new ArrayList<PropertyChangeListener>();
	
	public BridgeScene(){
		arthur = new Avatar(ARTHUR_LOCATION_X, ARTHUR_LOCATION_Y, ARTHUR_FILE_LOCATION);
		lancelot = new Avatar(LANCELOT_LOCATION_X, LANCELOT_LOCATION_Y, LANCELOT_FILE_LOCATION);
		robin = new Avatar(ROBIN_LOCATION_X, ROBIN_LOCATION_Y, ROBIN_FILE_LOCATION);
		galahad = new Avatar(GALAHAD_LOCATION_X, GALAHAD_LOCATION_Y, GALAHAD_FILE_LOCATION);
		guard = new Avatar(GUARD_LOCATION_X,GUARD_LOCATION_Y, GUARD_FILE_LOCATION);
		
		gorge = new GorgeWithBridge(GORGE_LEFT_X, GORGE_RIGHT_X, BRIDGE_Y, BRIDGE_WIDTH);
		knightArea = new Oval(KNIGHT_AREA_X, KNIGHT_AREA_Y, AREA_DIAMETERS, AREA_DIAMETERS);
		guardArea = new Oval(GUARD_AREA_X, GUARD_AREA_Y, AREA_DIAMETERS, AREA_DIAMETERS);
		
		occupied = false;
		knightTurn = false;
	}
	
	@Override
	@Tags({"approach"})
	public void approach(AvatarInterface knight){
		assert preApproach();	//cannot be occupied
		
		// Place knight in middle of proper area
		knight.setX(knightArea.getX() + knightArea.getWidth()/2);
		knight.setY(knightArea.getY() + knightArea.getHeight()/2);
		occupied = true;
		knightTurn = false;
		occupyingKnight = knight;
		
		// Can now say, pass, or fail, but not approach
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, APPROACH_METHOD_TAG, false));
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, SAY_METHOD_TAG, true));
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, PASSED_METHOD_TAG, true));
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, FAILED_METHOD_TAG, true));
	}
	
	@Override
	public boolean preApproach(){
		return !getOccupied();
	}
	
	@Override
	@Tags({"say"})
	public void say(String string){
		assert getOccupied();
		
		if (getKnightTurn()){
			occupyingKnight.getStringShape().setText(string);
			getGuard().getStringShape().setText(EMPTY_STRING);
			knightTurn = false;
		}else{
			getGuard().getStringShape().setText(string);
			occupyingKnight.getStringShape().setText(EMPTY_STRING);
			knightTurn = true;
		}
		
		// Pass alternates between being allowed and not allowed
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, PASSED_METHOD_TAG, prePassed()));
	}
	
	@Override
	public boolean preSay(){
		return getOccupied();
	}
	
	@Override
	@Tags({"passed"})
	public void passed(){
		assert prePassed();	// has to be occupied, has to be guard's turn
		
		occupyingKnight.setX(PASS_DESTINATION_X);
		
		// Reset challenge area
		occupyingKnight.getStringShape().setText(EMPTY_STRING);
		getGuard().getStringShape().setText(EMPTY_STRING);
		occupied = false;
		occupyingKnight = null;

		// Can now approach, but not say, pass, or fail
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, APPROACH_METHOD_TAG, true));
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, SAY_METHOD_TAG, false));
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, PASSED_METHOD_TAG, false));
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, FAILED_METHOD_TAG, false));
	}
	
	@Override
	public boolean prePassed(){
		return (getOccupied() && !getKnightTurn());
	}
	
	@Override
	@Tags({"failed"})
	public void failed(){
		assert preFailed();	//has to be occupied
		
		// if knight's turn, then guard falls
		if (getKnightTurn()){
			getGuard().getStringShape().setText(EMPTY_STRING);
			getGuard().setX(FAIL_DESTINATION_X);
			getGuard().setY(FAIL_DESTINATION_Y);
			
			// All preconditions stay the same
		}else{
			occupyingKnight.setX(FAIL_DESTINATION_X);
			occupyingKnight.setY(FAIL_DESTINATION_Y);
			occupyingKnight.getStringShape().setText(EMPTY_STRING);
			occupied = false;
			occupyingKnight = null;

			// Can now approach, but not say, pass, or fail
			notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, APPROACH_METHOD_TAG, true));
			notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, SAY_METHOD_TAG, false));
			notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, PASSED_METHOD_TAG, false));
			notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, FAILED_METHOD_TAG, false));
		}
	}
	
	@Override
	public boolean preFailed(){
		return getOccupied();
	}
	
	@Override
	@Tags({"scroll"})
	public void scroll(int scrollX, int scrollY) {
		arthur.move(-scrollX, -scrollY);
		lancelot.move(-scrollX, -scrollY);
		robin.move(-scrollX, -scrollY);
		galahad.move(-scrollX, -scrollY);
		guard.move(-scrollX, -scrollY);
		
		gorge.move(-scrollX, -scrollY);
		knightArea.move(-scrollX, -scrollY);
		guardArea.move(-scrollX, -scrollY);
	}
	
	@Override
	public boolean getOccupied(){
		return occupied;
	}
	
	@Override
	public boolean getKnightTurn(){
		return knightTurn;
	}
	
	@Override
	public GorgeWithBridgeInterface getGorge(){
		return gorge;
	}
	
	@Override
	public BoundedShapeInterface getKnightArea(){
		return knightArea;
	}
	
	@Override
	public BoundedShapeInterface getGuardArea(){
		return guardArea;
	}
	
	@Override
	public AvatarInterface getArthur() {
		return arthur;
	}

	@Override
	public AvatarInterface getLancelot() {
		return lancelot;
	}

	@Override
	public AvatarInterface getRobin() {
		return robin;
	}

	@Override
	public AvatarInterface getGalahad() {
		return galahad;
	}

	@Override
	public AvatarInterface getGuard() {
		return guard;
	}

	@Override
	public void addPropertyChangeListener(PropertyChangeListener listener) {
		listeners.add(listener);
	}
	
	protected void notifyAllListeners(PropertyChangeEvent e){
		for (PropertyChangeListener listener : listeners){
			listener.propertyChange(e);
		}
	}
}
//END OF FILE
//START OF FILE: src/grail/graphics/gorgewithbridge.java
package grail.graphics;

import grail.interfaces.GorgeWithBridgeInterface;
import grail.interfaces.BoundedShapeInterface;
import grail.interfaces.RotatingLineInterface;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Visible;

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"LeftSide", "RightSide", "Bridge", "LeftX", "RightX", "UpperY", "BridgeWidth", "GorgeLength"})
@EditablePropertyNames({"LeftX", "RightX", "UpperY", "BridgeWidth", "GorgeLength"})
public class GorgeWithBridge implements GorgeWithBridgeInterface {
	
	private static final int DEFAULT_UPPER_Y = -1000;
	private static final int DEFAULT_LENGTH = 4000;
	private static final double ANGLE_DOWNWARD = Math.PI/2;
	
	private RotatingLineInterface leftSide;
	private RotatingLineInterface rightSide;
	private BoundedShapeInterface bridge;
	
	// Constructors
	public GorgeWithBridge(int leftX, int rightX, int bridgeY, int bridgeWidth){
		leftSide = new RotatingLine(leftX, DEFAULT_UPPER_Y, DEFAULT_LENGTH, ANGLE_DOWNWARD);
		rightSide = new RotatingLine(rightX, DEFAULT_UPPER_Y, DEFAULT_LENGTH, ANGLE_DOWNWARD);
		
		// bridgeWidth refers to the width of the bridge, which is the height of the rectangle
		bridge = new Rectangle(leftX, bridgeY, rightX-leftX, bridgeWidth);
	}
	
	public GorgeWithBridge(int leftX, int rightX, int y, int gorgeLength, int bridgeY, int bridgeWidth){
		leftSide = new RotatingLine(leftX, y, gorgeLength, ANGLE_DOWNWARD);
		rightSide = new RotatingLine(rightX, y, gorgeLength, ANGLE_DOWNWARD);
		
		bridge = new Rectangle(leftX, bridgeY, rightX-leftX, bridgeWidth);
	}
	
	@Override
	public RotatingLineInterface getLeftSide(){
		return leftSide;
	}
	
	@Override
	public RotatingLineInterface getRightSide(){
		return rightSide;
	}
	
	@Override
	public BoundedShapeInterface getBridge(){
		return bridge;
	}
	
	@Override
	@Visible(false)
	public int getUpperY(){
		return leftSide.getY();
	}
	@Override
	@Visible(false)
	public void setUpperY(int y){
		leftSide.setY(y);
		rightSide.setY(y);
	}
	
	@Override
	@Visible(false)
	public int getLeftX(){
		return leftSide.getX();
	}
	@Override
	@Visible(false)
	public void setLeftX(int x){
		leftSide.setX(x);
		bridge.setX(x);
		bridge.setWidth(rightSide.getX() - x);
	}
	
	@Override
	@Visible(false)
	public int getRightX(){
		return rightSide.getX();
	}
	@Override
	@Visible(false)
	public void setRightX(int x){
		rightSide.setX(x);
		bridge.setWidth(x- leftSide.getX());
	}
	
	@Override
	@Visible(false)
	public int getBridgeWidth(){
		return bridge.getHeight();
	}
	@Override
	@Visible(false)
	public void setBridgeWidth(int width){
		bridge.setHeight(width);
	}
	
	@Override
	@Visible(false)
	public int getGorgeLength(){
		return (int)leftSide.getRadius();
	}
	@Override
	@Visible(false)
	public void setGorgeLength(int length){
		leftSide.setRadius(length);
		rightSide.setRadius(length);
	}

	@Override
	public void move(int moveX, int moveY) {
		leftSide.setX(leftSide.getX() + moveX);
		leftSide.setY(leftSide.getY() + moveY);
		rightSide.setX(rightSide.getX() + moveX);
		rightSide.setY(rightSide.getY() + moveY);
		bridge.move(moveX, moveY);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/graphics/image.java
package grail.graphics;

import java.beans.PropertyChangeEvent;

import javax.swing.Icon;
import javax.swing.ImageIcon;

import grail.interfaces.ImageInterface;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.IMAGE_PATTERN)
@PropertyNames({"X", "Y", "Width", "Height", "ImageFileName"})
@EditablePropertyNames({"X", "Y", "Width", "Height", "ImageFileName"})
public class Image extends Rectangle implements ImageInterface {

	private String imageFileName;
	
	public Image(int xPos, int yPos, int width, int height, String imageFileName){
		super(xPos, yPos, width, height);
		this.imageFileName = imageFileName;
	}
	
	public Image(int xPos, int yPos, String imageFileName){
		super(xPos, yPos, 0, 0);		//temporary height and width
		
		this.imageFileName = imageFileName;
		
		// Use image height and width
		Icon icon = new ImageIcon(imageFileName);
		setHeight(icon.getIconHeight());
		setWidth(icon.getIconWidth());
	}
	
	@Override
	public void setImageFileName(String newFileName) {
		String oldFileName = imageFileName;
		imageFileName = newFileName;
		notifyAllListeners(new PropertyChangeEvent(this, "ImageFileName", oldFileName, newFileName));
	}

	@Override
	public String getImageFileName() {
		return imageFileName;
	}

}
//END OF FILE
//START OF FILE: src/grail/graphics/locatableobject.java
package grail.graphics;

import grail.interfaces.Locatable;

public class LocatableObject implements Locatable{


	private int x;
	private int y;
	
	public LocatableObject(int xPos, int yPos){
		x = xPos;
		y = yPos;
	}
	
	// Empty constructor
	public LocatableObject(){}
	
	@Override
	public int getX() {
		return x;
	}
	
	@Override
	public void setX(int newX) {
		x = newX;
	}

	@Override
	public int getY() {
		return y;
	}
	
	@Override
	public void setY(int newY) {
		y = newY;
	}

}
//END OF FILE
//START OF FILE: src/grail/graphics/observablelocatableobject.java
package grail.graphics;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.List;

import grail.interfaces.ObservableLocatable;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"X", "Y"})
@EditablePropertyNames({"X", "Y"})
@Tags({"Locatable"})
public class ObservableLocatableObject extends LocatableObject implements ObservableLocatable{

	private List<PropertyChangeListener> listeners = new ArrayList<PropertyChangeListener>();
	
	public ObservableLocatableObject(int xPos, int yPos){
		super(xPos,yPos);
	}
	
	// Empty constructor
	public ObservableLocatableObject(){}
	
	@Override
	public void setX(int newX) {
		int oldX = getX();
		super.setX(newX);
		notifyAllListeners(new PropertyChangeEvent(this, "X", oldX, newX));
	}
	
	@Override
	public void setY(int newY) {
		int oldY = getY();
		super.setY(newY);
		notifyAllListeners(new PropertyChangeEvent(this, "Y", oldY, newY));
	}

	@Override
	public void addPropertyChangeListener(PropertyChangeListener listener) {
		listeners.add(listener);
	}
	
	protected void notifyAllListeners(PropertyChangeEvent e){
		for (PropertyChangeListener listener : listeners){
			listener.propertyChange(e);
		}
	}

}
//END OF FILE
//START OF FILE: src/grail/graphics/oval.java
package grail.graphics;

import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.OVAL_PATTERN)
@PropertyNames({"X", "Y", "Width", "Height"})
@EditablePropertyNames({"X", "Y", "Width", "Height"})
public class Oval extends BoundedShape{
	
	public Oval (int xPos, int yPos, int width, int height){
		super(xPos, yPos, width, height);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/graphics/rectangle.java
package grail.graphics;

import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.RECTANGLE_PATTERN)
@PropertyNames({"X", "Y", "Width", "Height"})
@EditablePropertyNames({"X", "Y", "Width", "Height"})
public class Rectangle extends BoundedShape {

	
	public Rectangle (int xPos, int yPos, int width, int height){
		super(xPos, yPos, width, height);
	}
	

}
//END OF FILE
//START OF FILE: src/grail/graphics/rotatingline.java
package grail.graphics;

import java.beans.PropertyChangeEvent;

import grail.interfaces.RotatingLineInterface;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"RotatingLine"})
@StructurePattern(StructurePatternNames.LINE_PATTERN)
@PropertyNames({"Height", "Width", "X", "Y","Angle", "Radius"})
@EditablePropertyNames({"X", "Y","Angle", "Radius"})
public class RotatingLine extends BoundedShape implements RotatingLineInterface{

	private static final double DEGREE_IN_RADIANS = Math.PI / 180;
	private static final double DEFAULT_RADIUS = 100;
	
	private double radius = DEFAULT_RADIUS;
	private double angle = 0;
	
	public RotatingLine(){
		setX(0);
		setY(0);
	}
	
	public RotatingLine(int xPos, int yPos, double r, double theta){
		setX(xPos);
		setY(yPos);
		radius = r;
		angle = theta;
	}
	
	@Override
	public int getHeight() {
		return (int)(radius*Math.sin(angle));
	}

	@Override
	public int getWidth() {
		return (int)(radius*Math.cos(angle));
	}

	@Override
	public void setRadius(double r) {
		int oldWidth = getWidth();
		int oldHeight = getHeight();
		
		radius = r;
		
		notifyAllListeners(new PropertyChangeEvent(this, "Width", oldWidth, getWidth()));
		notifyAllListeners(new PropertyChangeEvent(this, "Height", oldHeight, getHeight()));
	}

	@Override
	public double getRadius() {
		return radius;
	}

	/**
	 * Angle is in radians, clockwise from right horizontal
	 */
	@Override
	public void setAngle(double theta) {
		int oldWidth = getWidth();
		int oldHeight = getHeight();
		
		angle = theta;
		
		notifyAllListeners(new PropertyChangeEvent(this, "Width", oldWidth, getWidth()));
		notifyAllListeners(new PropertyChangeEvent(this, "Height", oldHeight, getHeight()));
	}
	
	/**
	 * Angle is in radians, clockwise from right horizontal
	 */
	@Override
	public double getAngle() {
		return angle;
	}

	@Override
	@Tags({"rotate"})
	public void rotateByClockwiseDegrees(int degrees) {
		setAngle(getAngle() + (degrees * DEGREE_IN_RADIANS));
	}

}
//END OF FILE
//START OF FILE: src/grail/graphics/stringshape.java
package grail.graphics;

import java.beans.PropertyChangeEvent;

import grail.interfaces.StringShapeInterface;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.STRING_PATTERN)
@PropertyNames({"X", "Y", "Text"})
@EditablePropertyNames({"X", "Y", "Text"})
public class StringShape extends ObservableLocatableObject implements StringShapeInterface {

	private String text;
	
	public StringShape(int xPos, int yPos, String text){
		super(xPos, yPos);
		this.text = text;
	}
	
	@Override
	public void setText(String newString) {
		String oldString = text;
		text = newString;
		notifyAllListeners(new PropertyChangeEvent(this, "Text", oldString, newString));
	}

	@Override
	public String getText() {
		return text;
	}

}
//END OF FILE
//START OF FILE: src/grail/graphics/vshape.java
package grail.graphics;

import java.beans.PropertyChangeListener;

import grail.interfaces.RotatingLineInterface;
import grail.interfaces.VShapeInterface;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;
import util.annotations.Visible;

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@Tags({"Angle"})
@PropertyNames({"X", "Y","LeftLine", "RightLine", "LinesLength"})
@EditablePropertyNames({"X", "Y", "LinesLength"})
public class VShape extends LocatableObject implements VShapeInterface {

	private RotatingLineInterface leftLine;
	private RotatingLineInterface rightLine;
	
	private static final double DEFAULT_LINE_LENGTH = 80;
	private static final double RIGHT_LINE_START_ANGLE = Math.PI/3;
	private static final double LEFT_LINE_START_ANGLE = 2*Math.PI/3;
	
	/**
	 * The only required constructor.
	 */
	public VShape(){
		rightLine = new RotatingLine(0, 0, DEFAULT_LINE_LENGTH, RIGHT_LINE_START_ANGLE);
		leftLine = new RotatingLine(0, 0, DEFAULT_LINE_LENGTH, LEFT_LINE_START_ANGLE);
		
		//Make the entire shape fit in the leftmost corner 
		setX(0 + Math.abs(leftLine.getWidth()));
		setY(0);
	}
	
	public VShape(int xPos, int yPos, double lineLengths){
		super(xPos, yPos);
		rightLine = new RotatingLine(xPos,yPos, lineLengths, RIGHT_LINE_START_ANGLE);
		leftLine = new RotatingLine(xPos,yPos, lineLengths, LEFT_LINE_START_ANGLE);
	}
	
	@Visible(false)
	@Override
	public void setX(int newX) {
		super.setX(newX);
		leftLine.setX(newX);
		rightLine.setX(newX);
	}

	@Visible(false)
	@Override
	public void setY(int newY) {
		super.setY(newY);
		leftLine.setY(newY);
		rightLine.setY(newY);
	}

	@Override
	public RotatingLineInterface getLeftLine() {
		return leftLine;
	}

	@Override
	public RotatingLineInterface getRightLine() {
		return rightLine;
	}

	@Override
	public void move(int changeInX, int changeInY) {
		setX(getX() + changeInX);
		setY(getY() + changeInY);
	}

	/**
	 * If line lengths differ, gives length of left line.
	 */
	@Override
	@Visible(false)
	public double getLinesLength() {
		return leftLine.getRadius();
	}

	@Override
	@Visible(false)
	public void setLinesLength(double newLength) {
		leftLine.setRadius(newLength);
		rightLine.setRadius(newLength);
	}
	
	@Override
	public void addPropertyChangeListenerToAtomics(PropertyChangeListener listener){
		getLeftLine().addPropertyChangeListener(listener);
		getRightLine().addPropertyChangeListener(listener);
	}
}
//END OF FILE
//START OF FILE: src/grail/interfaces/animatorinterface.java
package grail.interfaces;

import util.annotations.Tags;

public interface AnimatorInterface {
	@Tags({"animateAvatar"})
	public void animateAvatar(AvatarInterface avatar);
	
	void clapGuard(BridgeSceneInterface scene);
}
//END OF FILE
//START OF FILE: src/grail/interfaces/avatarinterface.java
package grail.interfaces;

import java.beans.PropertyChangeListener;

import util.annotations.Tags;

@Tags({"Avatar", "move"})
public interface AvatarInterface extends Locatable{
	
	public StringShapeInterface getStringShape();
	
	public ImageInterface getHead();
	
	public VShapeInterface getArms();
	
	public VShapeInterface getLegs();
	
	public RotatingLineInterface getTorso();
	
	public void move(int changeInX, int changeInY);
	public void scale(double scalar);

	void addPropertyChangeListenerToAtomics(PropertyChangeListener listener);
}
//END OF FILE
//START OF FILE: src/grail/interfaces/basehistory.java
package grail.interfaces;

public interface BaseHistory {
	public void addElement(Token element);
	public Token elementAt (int index); 
	public int size();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/boundedshapeinterface.java
package grail.interfaces;

import util.annotations.Tags;

@Tags({"BoundedShape"})
public interface BoundedShapeInterface extends ObservableLocatable{

	public void setWidth(int newWidth);
	public int getWidth();
	
	public void setHeight(int newHeight);
	public int getHeight();
	
	@Tags({"move"})
	public void move(int moveX, int moveY);
}
//END OF FILE
//START OF FILE: src/grail/interfaces/bridgesceneinterface.java
package grail.interfaces;

import util.annotations.Tags;
import util.models.PropertyListenerRegisterer;

@Tags({"BridgeScene"})
public interface BridgeSceneInterface extends PropertyListenerRegisterer{
	public AvatarInterface getArthur();
	public AvatarInterface getLancelot();
	public AvatarInterface getRobin();
	public AvatarInterface getGalahad();
	public AvatarInterface getGuard();
	
	public GorgeWithBridgeInterface getGorge();
	public BoundedShapeInterface getKnightArea();
	public BoundedShapeInterface getGuardArea();
	
	@Tags({"approach"})
	public void approach(AvatarInterface knight);
	
	@Tags({"say"})
	public void say(String string);
	
	@Tags({"passed"})
	public void passed();
	
	@Tags({"failed"})
	public void failed();
	public boolean getOccupied();
	public boolean getKnightTurn();
	
	@Tags({"scroll"})
	public void scroll(int scrollAmount, int i);
	
	public boolean preFailed();
	public boolean prePassed();
	public boolean preSay();
	public boolean preApproach();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/clearablehistoryinterface.java
package grail.interfaces;

import util.annotations.Tags;

@Tags({"ClearableHistory"})
public interface ClearableHistoryInterface extends BaseHistory {
	public void clear();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/commandinterpreterinterface.java
package grail.interfaces;

import java.beans.PropertyChangeListener;

import util.annotations.Tags;

@Tags({"CommandInterpreter", "SignedMoveCommandInterpreter", "ErrorResilientCommandInterpreter","ObservableCommandInterpreter"})
public interface CommandInterpreterInterface {

	public String getCommand();
	public void setCommand(String command);

	public String getErrors();
	public void addPropertyChangeListener(PropertyChangeListener listener);
	
	@Tags({"asynchronousArthur"})
	public void animateArthur();
	
	@Tags({"asynchronousGalahad"})
	public void animateGalahad();
	
	@Tags({"asynchronousLancelot"})
	public void animateLancelot();
	
	@Tags({"asynchronousRobin"})
	public void animateRobin();
	
	@Tags({"asynchronousGuard"})
	void clapGuard();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/commandthread.java
package grail.interfaces;

public interface CommandThread extends Runnable{

}
//END OF FILE
//START OF FILE: src/grail/interfaces/gorgewithbridgeinterface.java
package grail.interfaces;


public interface GorgeWithBridgeInterface {

	public RotatingLineInterface getLeftSide();
	public RotatingLineInterface getRightSide();
	public BoundedShapeInterface getBridge();

	public int getUpperY();
	public void setUpperY(int y);

	public int getLeftX();
	public void setLeftX(int x);

	public int getRightX();
	public void setRightX(int x);

	public int getBridgeWidth();
	public void setBridgeWidth(int width);

	public int getGorgeLength();
	public void setGorgeLength(int length);
	
	public void move(int moveX, int moveY);
}
//END OF FILE
//START OF FILE: src/grail/interfaces/imageinterface.java
package grail.interfaces;

import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.IMAGE_PATTERN)
public interface ImageInterface extends BoundedShapeInterface{
	public void setImageFileName(String imageFileName);
	public String getImageFileName();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/locatable.java
package grail.interfaces;

import util.annotations.Tags;

@Tags({"Locatable"})
public interface Locatable {
	
	public void setX(int newX);
	public int getX();

	public void setY(int newY);
	public int getY();
	
}
//END OF FILE
//START OF FILE: src/grail/interfaces/number.java
package grail.interfaces;

import util.annotations.Tags;

@Tags({"Number"})
public interface Number extends Token {
	public int getValue();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/observablelocatable.java
package grail.interfaces;

import util.models.PropertyListenerRegisterer;

public interface ObservableLocatable extends Locatable, PropertyListenerRegisterer{

}
//END OF FILE
//START OF FILE: src/grail/interfaces/rotatinglineinterface.java
package grail.interfaces;

import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@StructurePattern(StructurePatternNames.LINE_PATTERN)
@Tags({"RotatingLine"})
public interface RotatingLineInterface extends BoundedShapeInterface{

	public void setRadius(double r);
	public double getRadius();
	
	public void setAngle(double theta);
	public double getAngle();
	
	@Tags({"rotate"})
	public void rotateByClockwiseDegrees(int degrees);
}
//END OF FILE
//START OF FILE: src/grail/interfaces/scannerbeaninterface.java
package grail.interfaces;

import util.annotations.Tags;

@Tags({"ScannerBean"})
public interface ScannerBeanInterface {
	public String getScannedString();
	public void setScannedString(String s);
	public Token[] getTokens();
	public String[] getErrors();
	public ClearableHistoryInterface getTokenList();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/stringshapeinterface.java
package grail.interfaces;

import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.STRING_PATTERN)
public interface StringShapeInterface extends ObservableLocatable{
	
	public void setText(String newString);
	public String getText();
	
}
//END OF FILE
//START OF FILE: src/grail/interfaces/table.java
package grail.interfaces;

import util.annotations.Tags;

@Tags({"Table"})
public interface Table {

	void put(String key, Object val);

	Object get(String key);

}
//END OF FILE
//START OF FILE: src/grail/interfaces/token.java
package grail.interfaces;

import util.annotations.Tags;

@Tags({"Token", "Number", "Word", "Quote", "Plus", "Minus", "Start", "End"})
public interface Token {
	
	public void setInput(String newString);
	public String getInput();

}
//END OF FILE
//START OF FILE: src/grail/interfaces/vshapeinterface.java
package grail.interfaces;

import java.beans.PropertyChangeListener;

import util.annotations.Tags;

@Tags({"Angle", "move"})
public interface VShapeInterface extends Locatable{
	
	public RotatingLineInterface getLeftLine();
	public RotatingLineInterface getRightLine();
	
	public double getLinesLength();
	public void setLinesLength(double newLength);
	
	@Tags({"move"})
	public void move(int changeInX, int changeInY);
	
	void addPropertyChangeListenerToAtomics(PropertyChangeListener listener);
}
//END OF FILE
//START OF FILE: src/grail/interfaces/word.java
package grail.interfaces;
import util.annotations.Tags;

@Tags({"Word"})
public interface Word extends Token {
	public String getValue();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/mvc/bridgescenecontrollerinterface.java
package grail.interfaces.mvc;

import java.awt.event.KeyListener;
import java.awt.event.MouseListener;

import util.annotations.Tags;

@Tags({"BridgeSceneController"})
public interface BridgeSceneControllerInterface extends MouseListener, KeyListener {

}
//END OF FILE
//START OF FILE: src/grail/interfaces/mvc/commandinterpretercontrollerinterface.java
package grail.interfaces.mvc;

import java.awt.event.ActionListener;
import java.beans.PropertyChangeListener;

import javax.swing.JButton;
import javax.swing.JMenuItem;
import javax.swing.JTextField;

import util.annotations.Tags;

@Tags({"CommandInterpreterController"})
public interface CommandInterpreterControllerInterface extends ActionListener, PropertyChangeListener{
	public JTextField getTextField();
	public JButton getSay();
	public JButton getPass();
	public JButton getFail();
	public JButton getApproach();
	public JButton getButton();
	public JMenuItem getMenuItem();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/mvc/commandinterpreterviewinterface.java
package grail.interfaces.mvc;

import java.awt.event.ActionListener;
import java.beans.PropertyChangeListener;

import javax.swing.JButton;
import javax.swing.JMenuItem;
import javax.swing.JTextField;

import util.annotations.Tags;

@Tags({"CommandInterpreterView"})
public interface CommandInterpreterViewInterface extends PropertyChangeListener {
	public void addControllerListener(ActionListener listener);
	public JTextField getTextField();
	public JButton getSay();
	public JButton getApproach();
	public JButton getFail();
	public JButton getPass();
	public JButton getButton();
	public JMenuItem getMenuItem();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/mvc/delegatingbridgesceneviewinterface.java
package grail.interfaces.mvc;

import util.annotations.Tags;

@Tags({"DelegatingBridgeSceneView"})
public interface DelegatingBridgeSceneViewInterface {

}
//END OF FILE
//START OF FILE: src/grail/interfaces/mvc/paintlistener.java
package grail.interfaces.mvc;

import java.awt.Graphics2D;
import java.beans.PropertyChangeListener;

import util.annotations.Tags;

@Tags({"PaintListener"})
public interface PaintListener extends PropertyChangeListener{
	void paint(Graphics2D g);
}
//END OF FILE
//START OF FILE: src/grail/interfaces/mvc/paintingviewmaster.java
package grail.interfaces.mvc;

import util.annotations.Tags;

@Tags({"ObservableBridgeScenePainter"})
public interface PaintingViewMaster {
	public void addPaintListener(PaintListener listener);
	public void repaint();
}
//END OF FILE
//START OF FILE: src/grail/mvc/controller/bridgescenecontroller.java
package grail.mvc.controller;

import java.awt.Component;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;

import grail.SingletonsCreator;
import grail.interfaces.AvatarInterface;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.mvc.BridgeSceneControllerInterface;
import grail.interfaces.mvc.PaintingViewMaster;
import util.annotations.Tags;

@Tags({"BridgeSceneController"})
public class BridgeSceneController implements BridgeSceneControllerInterface{
	
	PaintingViewMaster painter;
	BridgeSceneInterface scene;
	
	private int lastClickX;
	private int lastClickY;
	private boolean clicked = false;	// to only respond to keys after click
	
	public BridgeSceneController(PaintingViewMaster painter){
		this.painter = painter;
		scene = SingletonsCreator.bridgeSceneFactoryMethod();
		((Component)painter).addKeyListener(this);
		((Component)painter).setFocusable(true);
		((Component)painter).addMouseListener(this);
	}

	@Override
	public void mouseClicked(MouseEvent e) {
		clicked = true;
		lastClickX = e.getX();
		lastClickY = e.getY();
	}
	
	@Override
	public void keyTyped(KeyEvent e) {
		// Do nothing if haven't clicked
		if (!clicked){
			return;
		}
		
		AvatarInterface knightToMove = null;
		switch (e.getKeyChar()){
		case 'a':
			knightToMove = scene.getArthur();
			break;
		case 'g':
			knightToMove = scene.getGalahad();
			break;
		case 'l':
			knightToMove = scene.getLancelot();
			break;
		case 'r':
			knightToMove = scene.getRobin();
			break;
		}
		
		if (knightToMove != null){
			knightToMove.setX(lastClickX);
			knightToMove.setY(lastClickY);
		}
	}
	
	
	
	/* Unused: */
	
	@Override
	public void mouseEntered(MouseEvent e) {}

	@Override
	public void mouseExited(MouseEvent e) {}

	@Override
	public void mousePressed(MouseEvent e) {}

	@Override
	public void mouseReleased(MouseEvent e) {}

	@Override
	public void keyPressed(KeyEvent e) {}

	@Override
	public void keyReleased(KeyEvent e) {}
}
//END OF FILE
//START OF FILE: src/grail/mvc/controller/commandinterpretercontroller.java
package grail.mvc.controller;

import java.awt.event.ActionEvent;
import java.beans.PropertyChangeEvent;

import javax.swing.JButton;
import javax.swing.JMenuItem;
import javax.swing.JTextField;

import grail.SingletonsCreator;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandInterpreterInterface;
import grail.interfaces.mvc.CommandInterpreterViewInterface;
import grail.mvc.view.CommandInterpreterView;
import grail.interfaces.mvc.CommandInterpreterControllerInterface;
import util.annotations.PropertyNames;
import util.annotations.Tags;

@Tags({"CommandInterpreterController"})
@PropertyNames({"TextField", "Say", "Pass", "Fail", "Approach", "MenuItem", "Button"})
public class CommandInterpreterController implements CommandInterpreterControllerInterface {
	
	public static final String SAY_TAG = "Say";
	public static final String APPROACH_TAG = "Approach";
	public static final String PASS_TAG = "Passed";
	public static final String FAIL_TAG = "Failed";
	
	private static final String MOVE_ARTHUR_LEFT_COMMAND = "move arthur - 20 0";
	private static final String MOVE_ARTHUR_RIGHT_COMMAND = "move arthur 20 0";
	private static final String SAY_COMMAND = "say \"Guess someone clicked a button\"";
	
	private CommandInterpreterInterface interpreter;
	private CommandInterpreterViewInterface uiFrame;
	private BridgeSceneInterface scene;
	
	private JTextField textField;
	private JButton sayButton;
	private JButton approachButton;
	private JButton failButton;
	private JButton passButton;
	
	public CommandInterpreterController(CommandInterpreterViewInterface frame){
		uiFrame = frame;
		frame.addControllerListener(this);
		
		textField = frame.getTextField();
		sayButton = frame.getSay();
		approachButton = frame.getApproach();
		failButton = frame.getFail();
		passButton = frame.getPass();
		
		interpreter = SingletonsCreator.commandInterpreterFactoryMethod();
		interpreter.addPropertyChangeListener(this);
		
		scene = SingletonsCreator.bridgeSceneFactoryMethod();
		scene.addPropertyChangeListener(this);
		
		//Set initial buttons settings
		sayButton.setEnabled(scene.preSay());
		approachButton.setEnabled(scene.preApproach());
		failButton.setEnabled(scene.preFailed());
		passButton.setEnabled(scene.prePassed());
	}

	@Override
	public JTextField getTextField(){
		return textField;
	}
	
	@Override
	public JButton getSay(){
		return sayButton;
	}
	
	@Override
	public JButton getPass(){
		return passButton;
	}
	
	@Override
	public JButton getFail(){
		return failButton;
	}
	
	@Override
	public JButton getApproach(){
		return approachButton;
	}

	@Override
	public JButton getButton() {
		return uiFrame.getButton();
	}

	@Override
	public JMenuItem getMenuItem() {
		return uiFrame.getMenuItem();
	}

	@Override
	public void actionPerformed(ActionEvent event) {
		Object source =event.getSource();
		
		if (source == textField){
			interpreter.setCommand(event.getActionCommand());
			return;
			
		}else if (source == sayButton){
			interpreter.setCommand(SAY_COMMAND);
			
		}else if (source == approachButton){
			scene.approach(scene.getArthur());
			
		}else if (source == passButton){
			scene.passed();
			
		}else if (source == failButton){
			scene.failed();
			
		}else	if (CommandInterpreterView.MOVE_ARTHUR_LEFT.equals(event.getActionCommand())){
			interpreter.setCommand(MOVE_ARTHUR_LEFT_COMMAND);
		
		}else if (CommandInterpreterView.MOVE_ARTHUR_RIGHT.equals(event.getActionCommand())){
			interpreter.setCommand(MOVE_ARTHUR_RIGHT_COMMAND);
			
		}
	}

	@Override
	public void propertyChange(PropertyChangeEvent event) {
		String methodName = (String)(event.getOldValue());
		Object newValue= event.getNewValue();
		
		if (SAY_TAG.equalsIgnoreCase(methodName)){
			sayButton.setEnabled((Boolean)newValue);
			
		} else if (APPROACH_TAG.equalsIgnoreCase(methodName)){
			approachButton.setEnabled((Boolean)newValue);
			
		}else if (PASS_TAG.equalsIgnoreCase(methodName)){
			passButton.setEnabled((Boolean)newValue);
			
		}else if (FAIL_TAG.equalsIgnoreCase(methodName)){
			failButton.setEnabled((Boolean)newValue);
		}
	}


}
//END OF FILE
//START OF FILE: src/grail/mvc/view/avatarview.java
package grail.mvc.view;

import java.awt.Graphics2D;
import java.beans.PropertyChangeEvent;

import grail.interfaces.AvatarInterface;
import grail.interfaces.mvc.PaintListener;
import grail.interfaces.mvc.PaintingViewMaster;
import util.annotations.Tags;

@Tags({"PaintListener"})
public class AvatarView implements PaintListener{
	
	PaintingViewMaster painter;
	AvatarInterface avatar;
	
	public AvatarView(AvatarInterface avatar, PaintingViewMaster painter){
		this.painter = painter;
		this.avatar = avatar;
		
		avatar.addPropertyChangeListenerToAtomics(this);
	}

	@Override
	public void propertyChange(PropertyChangeEvent evt) {
		painter.repaint();
	}
	
	@Override
	public void paint(Graphics2D g){
		PaintingSupport.paintAvatar(g, avatar);
	}
}
//END OF FILE
//START OF FILE: src/grail/mvc/view/commandinterpreterview.java
package grail.mvc.view;

import java.awt.GridLayout;
import java.awt.event.ActionListener;
import java.beans.PropertyChangeEvent;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JTextField;

import grail.SingletonsCreator;
import grail.interfaces.CommandInterpreterInterface;
import grail.interfaces.mvc.CommandInterpreterViewInterface;
import util.annotations.PropertyNames;
import util.annotations.Tags;

@Tags({"CommandInterpreterView"})
@PropertyNames({"TextField", "ProgressBar", "Say", "Pass", "Fail", "Approach", "MenuItem", "Button"})
public class CommandInterpreterView extends JFrame implements CommandInterpreterViewInterface{
	
	private static final int FRAME_ROWS = 4;
	private static final int FRAME_COLUMNS = 1;
	private static final int PANEL_ROWS = 1;
	private static final int PANEL_COLUMNS = 2;
	private static final String ERRORS_PROPERTY = "Errors";
	
	private static final int BUTTON_GRID_ROWS = 2;
	private static final int BUTTON_GRID_COLUMNS = 2;
	
	public static final String MOVE_ARTHUR_LEFT = "Move Arthur left";
	public static final String MOVE_ARTHUR_RIGHT = "Move Arthur right";
	public static final String SAY = "Say";
	public static final String APPROACH = "Approach";
	public static final String PASS = "Pass";
	public static final String FAIL = "Fail";
	
	private JLabel commandLabel;
	private JTextField commandField;
	
	private JMenuItem moveArthurLeft;
	private JButton moveArthurRight;
	
	private JTextField errorField;
	private JLabel errorLabel;
	
	private JButton sayButton;
	private JButton approachButton;
	private JButton failButton;
	private JButton passButton;
	
	private CommandInterpreterInterface interpreter;
	
	public CommandInterpreterView(){
		super("CommandInterpreter UI");
		
		interpreter = SingletonsCreator.commandInterpreterFactoryMethod();
		interpreter.addPropertyChangeListener(this);
		
		setLayout(new GridLayout(FRAME_ROWS, FRAME_COLUMNS));
		
		commandField = new JTextField("");
		commandLabel = new JLabel("Command:");
		JPanel commandPanel = new JPanel();
		commandPanel.setLayout(new GridLayout(PANEL_ROWS, PANEL_COLUMNS));
		commandPanel.add(commandLabel);
		commandPanel.add(commandField);
		
		errorField = new JTextField();
		errorField.setEditable(false);
		errorLabel = new JLabel("Errors:");
		JPanel errorPanel = new JPanel();
		errorPanel.setLayout(new GridLayout(PANEL_ROWS, PANEL_COLUMNS));
		errorPanel.add(errorLabel);
		errorPanel.add(errorField);
		
		moveArthurLeft = new JMenuItem(MOVE_ARTHUR_LEFT);
		JMenu menu = new JMenu("move");
		JMenuBar menuBar = new JMenuBar();
		menu.add(moveArthurLeft);
		menuBar.add(menu);
		
		moveArthurRight = new JButton(MOVE_ARTHUR_RIGHT);
		
		sayButton = new JButton(SAY);
		approachButton = new JButton(APPROACH);
		failButton = new JButton(FAIL);
		passButton = new JButton(PASS);
		
		JPanel buttonGrid = new JPanel();
		buttonGrid.setLayout(new GridLayout(BUTTON_GRID_ROWS, BUTTON_GRID_COLUMNS));
		buttonGrid.add(sayButton);
		buttonGrid.add(approachButton);
		buttonGrid.add(failButton);
		buttonGrid.add(passButton);
		
		
		setJMenuBar(menuBar);
		add(commandPanel);
		add(moveArthurRight);
		add(errorPanel);
		add(buttonGrid);
	}

	@Override
	public void addControllerListener(ActionListener listener) {
		commandField.addActionListener(listener);
		moveArthurLeft.addActionListener(listener);
		moveArthurRight.addActionListener(listener);
		sayButton.addActionListener(listener);
		approachButton.addActionListener(listener);
		failButton.addActionListener(listener);
		passButton.addActionListener(listener);
	}

	@Override
	public void propertyChange(PropertyChangeEvent event) {
		if (event.getPropertyName().equalsIgnoreCase(ERRORS_PROPERTY)){
			errorField.setText(interpreter.getErrors());
		}
	}
	
	@Override
	public JTextField getTextField(){
		return commandField;
	}
	
	@Override
	public JButton getSay(){
		return sayButton;
	}
	
	@Override
	public JButton getApproach(){
		return approachButton;
	}
	
	@Override
	public JButton getFail(){
		return failButton;
	}
	
	@Override
	public JButton getPass(){
		return passButton;
	}
	@Override
	public JButton getButton(){
		return moveArthurRight;
	}
	@Override
	public JMenuItem getMenuItem(){
		return moveArthurLeft;
	}

}
//END OF FILE
//START OF FILE: src/grail/mvc/view/consolesceneview.java
package grail.mvc.view;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import grail.SingletonsCreator;
import grail.interfaces.BridgeSceneInterface;
import util.annotations.Tags;

@Tags({"ConsoleSceneView"})
public class ConsoleSceneView implements PropertyChangeListener{

	/**
	 * Constructor automatically registers this class as an observer of BridgeSceneInterface
	 */
	public ConsoleSceneView(){
		BridgeSceneInterface scene = SingletonsCreator.bridgeSceneFactoryMethod();
		
		// Register as listener of knights
		scene.getArthur().addPropertyChangeListenerToAtomics(this);
		scene.getGalahad().addPropertyChangeListenerToAtomics(this);
		scene.getGuard().addPropertyChangeListenerToAtomics(this);
		scene.getLancelot().addPropertyChangeListenerToAtomics(this);
		scene.getRobin().addPropertyChangeListenerToAtomics(this);
			
		SceneBackgroundView.registerAsListenerOfBackground(scene, this);
		
		scene.addPropertyChangeListener(this); // for assertion events
	}
	
	@Override
	public void propertyChange(PropertyChangeEvent evt) {
		System.out.println(evt);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/mvc/view/delegatingbridgesceneview.java
package grail.mvc.view;

import grail.SingletonsCreator;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.mvc.DelegatingBridgeSceneViewInterface;
import grail.interfaces.mvc.PaintingViewMaster;
import util.annotations.Tags;

@Tags({"DelegatingBridgeSceneView"})
public class DelegatingBridgeSceneView implements DelegatingBridgeSceneViewInterface{
	
	public DelegatingBridgeSceneView(BridgeSceneInterface scene){
		PaintingViewMaster painter = SingletonsCreator.observableBridgeScenePainterFactoryMethod();
		
		painter.addPaintListener(new AvatarView(scene.getArthur(), painter));
		painter.addPaintListener(new AvatarView(scene.getGalahad(), painter));
		painter.addPaintListener(new AvatarView(scene.getGuard(), painter));
		painter.addPaintListener(new AvatarView(scene.getLancelot(), painter));
		painter.addPaintListener(new AvatarView(scene.getRobin(), painter));
		
		painter.addPaintListener(new SceneBackgroundView(scene, painter));
	}
	
}
//END OF FILE
//START OF FILE: src/grail/mvc/view/observablebridgescenepainter.java
package grail.mvc.view;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.util.ArrayList;
import java.util.List;

import grail.interfaces.mvc.PaintListener;
import grail.interfaces.mvc.PaintingViewMaster;
import util.annotations.Tags;

@Tags({"ObservableBridgeScenePainter"})
public class ObservableBridgeScenePainter extends Component implements PaintingViewMaster{
	
	List<PaintListener> listeners;
	
	public ObservableBridgeScenePainter() {
		listeners = new ArrayList<PaintListener>();
		setFocusable(true);
	}
	
	@Override
	@Tags({"addPaintListener"})
	public void addPaintListener(PaintListener listener){
		listeners.add(listener);
	}
	
	@Override
	public void paint(Graphics g){
		super.paint(g);
		
		for (PaintListener listener : listeners){
			listener.paint((Graphics2D) g);
		}
	}
}
//END OF FILE
//START OF FILE: src/grail/mvc/view/paintingsupport.java
package grail.mvc.view;

import java.awt.Graphics2D;
import java.awt.Toolkit;

import grail.interfaces.AvatarInterface;
import grail.interfaces.BoundedShapeInterface;
import grail.interfaces.ImageInterface;
import grail.interfaces.RotatingLineInterface;
import grail.interfaces.StringShapeInterface;
import grail.interfaces.VShapeInterface;

public class PaintingSupport {
	
	public static void paintRectangle(Graphics2D g, BoundedShapeInterface shape){
		g.drawRect(shape.getX(), shape.getY(), shape.getWidth(), shape.getHeight());
	}
	
	public static void paintOval(Graphics2D g, BoundedShapeInterface shape){
		g.drawOval(shape.getX(), shape.getY(), shape.getWidth(), shape.getHeight());
	}
	
	public static void paintStringShape(Graphics2D g, StringShapeInterface shape){
		g.drawString(shape.getText(), shape.getX(), shape.getY());
	}
	
	public static void paintImage(Graphics2D g, ImageInterface shape){
		g.drawImage(Toolkit.getDefaultToolkit().getImage(shape.getImageFileName()),
				shape.getX(), shape.getY(), null);
	}
	
	public static void paintLine(Graphics2D g, RotatingLineInterface line){
		g.drawLine(line.getX(), line.getY(), line.getX() + line.getWidth(), line.getY()+line.getHeight());
	}
	
	public static void paintVShape(Graphics2D g, VShapeInterface shape){
		paintLine(g, shape.getLeftLine());
		paintLine(g, shape.getRightLine());
	}
	
	public static void paintAvatar(Graphics2D g, AvatarInterface avatar){
		paintImage(g, avatar.getHead());
		paintLine(g, avatar.getTorso());
		paintStringShape(g, avatar.getStringShape());
		paintVShape(g, avatar.getArms());
		paintVShape(g, avatar.getLegs());
	}
}
//END OF FILE
//START OF FILE: src/grail/mvc/view/scenebackgroundview.java
package grail.mvc.view;

import java.awt.Graphics2D;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.mvc.PaintListener;
import grail.interfaces.mvc.PaintingViewMaster;
import util.annotations.Tags;

@Tags({"PaintListener"})
public class SceneBackgroundView implements PaintListener{
	BridgeSceneInterface scene;
	PaintingViewMaster painter;
	
	public SceneBackgroundView(BridgeSceneInterface scene, PaintingViewMaster painter){
		this.scene = scene;
		this.painter = painter;
		
		// Register for gorge
		scene.getGorge().getBridge().addPropertyChangeListener(this);
		scene.getGorge().getLeftSide().addPropertyChangeListener(this);
		scene.getGorge().getRightSide().addPropertyChangeListener(this);
		
		scene.getGuardArea().addPropertyChangeListener(this);
		scene.getKnightArea().addPropertyChangeListener(this);
	}
	
	public static void registerAsListenerOfBackground(BridgeSceneInterface scene, PropertyChangeListener listener){	
		
		// Register for gorge
		scene.getGorge().getBridge().addPropertyChangeListener(listener);
		scene.getGorge().getLeftSide().addPropertyChangeListener(listener);
		scene.getGorge().getRightSide().addPropertyChangeListener(listener);
		
		scene.getGuardArea().addPropertyChangeListener(listener);
		scene.getKnightArea().addPropertyChangeListener(listener);
	}

	@Override
	public void propertyChange(PropertyChangeEvent evt) {
		painter.repaint();
	}

	@Override
	public void paint(Graphics2D g) {
		PaintingSupport.paintLine(g, scene.getGorge().getLeftSide());
		PaintingSupport.paintLine(g, scene.getGorge().getRightSide());
		PaintingSupport.paintRectangle(g, scene.getGorge().getBridge());
		PaintingSupport.paintOval(g, scene.getGuardArea());
		PaintingSupport.paintOval(g, scene.getKnightArea());
	}
	
	
}
//END OF FILE
//START OF FILE: src/grail/scanner/commandinterpreter.java
package grail.scanner;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.List;

import grail.SingletonsCreator;
import grail.animations.AnimatingCommand;
import grail.animations.Animator;
import grail.animations.ClapCommand;
import grail.interfaces.AvatarInterface;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandInterpreterInterface;
import grail.interfaces.CommandThread;
import grail.interfaces.ScannerBeanInterface;
import grail.interfaces.Table;
import grail.interfaces.Token;
import grail.interfaces.Word;
import grail.scanner.commands.MoveCommand;
import grail.scanner.commands.SayCommand;
import grail.tokenBeans.MinusToken;
import grail.tokenBeans.NumberToken;
import grail.tokenBeans.PlusToken;
import grail.tokenBeans.QuoteToken;
import grail.tokenBeans.commandBeans.MoveCommandToken;
import grail.tokenBeans.commandBeans.SayCommandToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;
import grail.interfaces.Number;

@Tags({"CommandInterpreter", "SignedMoveCommandInterpreter", "ErrorResilientCommandInterpreter","ObservableCommandInterpreter"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Command", "Errors"})
@EditablePropertyNames({"Command"})
public class CommandInterpreter implements CommandInterpreterInterface {
	private static final String EOI = "end of input";
	private static final String QUOTE_TOKEN = "quoted string";
	private static final String COMMAND = "move or say";
	private static final String NUMBER_TOKEN = "integer";
	private static final String AVATAR_NAME = "avatar name";

	private List<PropertyChangeListener> listeners = new ArrayList<PropertyChangeListener>();
	
	// Key references
	private ScannerBeanInterface scannerBean;
	private BridgeSceneInterface scene;
	
	// Required table
	private Table avatars;
	
	// fields that back properties
	private String command ="";
	private String errorString = "";
	
	// Convenience fields- these could be passed as parameters
	private Token[] tokens;
	private Token currentToken;
	private int currentIndex;
	
	// Needed since not using exceptions, to let called functions 
	// indicate whether they succeeded
	boolean parsingError;
	
	// Constructor
	public CommandInterpreter(BridgeSceneInterface scene, ScannerBeanInterface scannerBean){
		this.scannerBean = scannerBean;
		this.scene = scene;
		avatars = SingletonsCreator.avatarTableFactoryMethod();
	}
	
	@Override
	public String getCommand(){
		return command;
	}
	
	@Override
	public void setCommand(String command){
		this.command = command;
		String oldErrorString = errorString;	//used for notifying about change
		errorString = "";
		scannerBean.setScannedString(command);
		tokens = scannerBean.getTokens();
		
		// Check for unparseable tokens
		String[] errors = scannerBean.getErrors();
		if (scannerBean.getErrors().length != 0){
			errorString = "ERROR- Invalid tokens in command: " + errors[0];
			for (int i = 1; i < errors.length; ++i){
				errorString += (", " + errors[i]);
			}
		
		// If no unparsable tokens
		}else{
			currentIndex = 0;
			
			// Grader requires having the parse calls be done from this setter,
			// hence the executeCommand() call is inlined here.
			{
				CommandThread commandThread = null;
				
				if (currentIndex >= tokens.length){
					fillErrorString(EOI, COMMAND);
					return;
				}
				
				currentToken = tokens[currentIndex];
				
				// Parse:
				// Check if it's a say command
				if (currentToken instanceof SayCommandToken){
					++currentIndex;
					commandThread = parseSay();
					
				// Check if it's a move command
				}else if (currentToken instanceof MoveCommandToken){
					++currentIndex;
					commandThread = parseMove();
					
				}else {
					fillErrorString(currentToken.getInput(), COMMAND);
					return;
				}
				
				// Execute:
				if (null == commandThread){
					return;
				}else{
					commandThread.run();
				}
			}//end inline executeCommand()
		}
		notifyAllListeners("Errors", oldErrorString, errorString);
	}//end setCommand
	
	/**
	 * This, like the other helper functions, expects currentIndex to be set
	 * to the index in tokens of the command to be parsed, and leaves currentIndex
	 * pointing to right past the last command token. 
	 * 
	 */
	private void executeCommand(){
		CommandThread commandThread = null;
		
		if (currentIndex >= tokens.length){
			fillErrorString(EOI, COMMAND);
			return;
		}
		
		currentToken = tokens[currentIndex];
		
		// Parse:
		// Check if it's a say command
		if (currentToken instanceof SayCommandToken){
			++currentIndex;
			commandThread = parseSay();
			
		// Check if it's a move command
		}else if (currentToken instanceof MoveCommandToken){
			++currentIndex;
			commandThread = parseMove();
			
		}else {
			fillErrorString(currentToken.getInput(), COMMAND);
			return;
		}
		
		// Execute:
		if (null == commandThread){
			return;
		}else{
			commandThread.run();
		}
	}
	
	/**
	 * Requires currentIndex to be set to just past a say token.
	 * 
	 * Returns null if invalid.
	 */
	@Tags({"parseSay"})
	private CommandThread parseSay() {
		String quote;
		
		// Check for additional token
		if (currentIndex >= tokens.length){
			fillErrorString(EOI, QUOTE_TOKEN);
			return null;
		}
		
		currentToken = tokens[currentIndex];
		
		// Make sure it's a quote
		if (currentToken instanceof QuoteToken){
			quote = tokens[currentIndex].getInput();
		
		}else {	
			fillErrorString(currentToken.getInput(), QUOTE_TOKEN);
			return null;
		}

		++currentIndex;
		
		// Make sure command has ended
		if (!(currentIndex >= tokens.length)){
			fillErrorString(tokens[currentIndex].getInput(), EOI);
			return null;
		}
		
		return new SayCommand(scene, quote);
	}

	/**
	 * Requires currentIndex to be set to just past a move token.
	 * 
	 * Returns null if invalid.
	 */
	@Tags({"parseMove"})
	private CommandThread parseMove() {
		String avatarName;
		int moveX;
		int moveY;
		
		// Check for additional token
		if (currentIndex >= tokens.length){
			fillErrorString(EOI, AVATAR_NAME);
			return null;
		}
		
		currentToken = tokens[currentIndex];
		
		// Make sure it's a word
		if (currentToken instanceof Word){
			avatarName = ((Word)currentToken).getValue();
		
		}else {	
			fillErrorString(currentToken.getInput(), AVATAR_NAME);
			return null;
		}
		
		// Check that word is valid avatar name
		AvatarInterface avatar = (AvatarInterface)avatars.get(avatarName);
		if (null == avatar){
			fillErrorString(currentToken.getInput(), AVATAR_NAME);
			return null;
		}
		
		++currentIndex;
		
		moveX = processSignedInteger();
		if (parsingError){
			return null;
		}
		moveY = processSignedInteger();
		if (parsingError){
			return null;
		}
		
		// Make sure command has ended
		if (!(currentIndex >= tokens.length)){
			fillErrorString(tokens[currentIndex].getInput(), EOI);
			return null;
		}
		
		return new MoveCommand(avatar, moveX, moveY);
	}
	
	/**
	 * Expects currentIndex to be pointing to first token of signed integer,
	 * and leaves it pointing just past the last token. Sets parsingError to
	 * true if there was an incorrect token (reports it itself in console).
	 * 
	 * @return parsed signed integer.
	 */
	private int processSignedInteger() {

		parsingError = false;
		int returnValue = 1;
		
		// Check for additional token
		if (currentIndex >= tokens.length){
			fillErrorString(EOI, NUMBER_TOKEN);
			parsingError = true;
			return 0;
		}
		
		currentToken = tokens[currentIndex];
		
		// See if it's a sign
		if (currentToken instanceof PlusToken){
			++currentIndex;
			
			// Check for additional token after sign
			if (currentIndex >= tokens.length){
				fillErrorString(EOI, NUMBER_TOKEN);
				parsingError = true;
				return 0;
			}
		
		} else if (currentToken instanceof MinusToken) {
			returnValue *= -1;
			++currentIndex;
			
			// Check for additional token
			if (currentIndex >= tokens.length){
				fillErrorString(EOI, NUMBER_TOKEN);
				parsingError = true;
				return 0;
			}
		}

		currentToken = tokens[currentIndex];
		if (currentToken instanceof NumberToken){
			returnValue *= ((Number)currentToken).getValue();
		}else{
			fillErrorString(currentToken.getInput(), NUMBER_TOKEN);
			parsingError = true;
			return 0;
		}
		++currentIndex;
		
		return returnValue;
	}

	private void fillErrorString(String encountered, String expected) {
		errorString = "ERROR- Encountered: " + encountered 
				+ " Expected: " + expected;
	}

	@Override
	public String getErrors() {
		return errorString;
	}

	@Override
	public void addPropertyChangeListener(PropertyChangeListener listener) {
		listeners.add(listener);
	}
	
	private void notifyAllListeners(String propertyName, Object oldValue, Object newValue){
		for (PropertyChangeListener listener : listeners){
			listener.propertyChange(new PropertyChangeEvent(this, propertyName, oldValue, newValue));
		}
	}

	@Override
	@Tags({"asynchronousArthur"})
	public void animateArthur() {
		Thread thread = new Thread(new AnimatingCommand(new Animator(), scene.getArthur()));
		thread.start();
	}

	@Tags({"asynchronousGalahad"})
	@Override
	public void animateGalahad() {
		Thread thread = new Thread(new AnimatingCommand(new Animator(), scene.getGalahad()));
		thread.start();
	}

	@Tags({"asynchronousLancelot"})
	@Override
	public void animateLancelot() {
		Thread thread = new Thread(new AnimatingCommand(new Animator(), scene.getLancelot()));
		thread.start();
	}

	@Override
	@Tags({"asynchronousRobin"})
	public void animateRobin() {
		Thread thread = new Thread(new AnimatingCommand(new Animator(), scene.getRobin()));
		thread.start();
	}
	
	@Override
	@Tags({"asynchronousGuard"})
	public void clapGuard(){
		Thread thread = new Thread(new ClapCommand(new Animator(), scene));
		thread.start();
	}
	
	
}
//END OF FILE
//START OF FILE: src/grail/scanner/scannerbean.java
package grail.scanner;

import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

import java.util.Iterator;

import grail.collections.ClearableHistory;
import grail.interfaces.ClearableHistoryInterface;
import grail.interfaces.ScannerBeanInterface;
import grail.interfaces.Token;
import grail.tokenBeans.EndToken;
import grail.tokenBeans.MinusToken;
import grail.tokenBeans.NumberToken;
import grail.tokenBeans.PlusToken;
import grail.tokenBeans.QuoteToken;
import grail.tokenBeans.StartToken;
import grail.tokenBeans.WordToken;
import grail.tokenBeans.commandBeans.ApproachCommandToken;
import grail.tokenBeans.commandBeans.FailCommandToken;
import grail.tokenBeans.commandBeans.MoveCommandToken;
import grail.tokenBeans.commandBeans.PassCommandToken;
import grail.tokenBeans.commandBeans.RepeatCommandToken;
import grail.tokenBeans.commandBeans.SayCommandToken;
import grail.tokenBeans.extraCommandBeans.CallCommandToken;
import grail.tokenBeans.extraCommandBeans.DefineCommandToken;
import grail.tokenBeans.extraCommandBeans.ProceedAllCommandToken;
import grail.tokenBeans.extraCommandBeans.RedoCommandToken;
import grail.tokenBeans.extraCommandBeans.RotateLeftArmCommandToken;
import grail.tokenBeans.extraCommandBeans.RotateRightArmCommandToken;
import grail.tokenBeans.extraCommandBeans.SleepCommandToken;
import grail.tokenBeans.extraCommandBeans.ThreadCommandToken;
import grail.tokenBeans.extraCommandBeans.UndoCommandToken;
import grail.tokenBeans.extraCommandBeans.WaitCommandToken;


/**
 * A "Bean" object whose setter for scannedString prints the tokens and their types.
 * @author Semion
 *
 */
@Tags({"ScannerBean"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"ScannedString", "Tokens", "Errors", "TokenList"})
@EditablePropertyNames({"ScannedString"})
public class ScannerBean implements ScannerBeanInterface{

	private String scannedString = "";
	
	private ClearableHistoryInterface tokenList = new ClearableHistory();
	
	private Token[] tokenStorage = new Token[100];
	private Token[] tokens = {};
	private int numTokens = 0;
	
	private String[] errorStorage = new String[100];
	private String[] errors = {};
	private int numErrors = 0;
	
	@Override
	public String getScannedString(){
		return scannedString;
	};
	
	@Override
	public void setScannedString(String s){
		scanString(s);
		scannedString = s;
	};
	
	@Override	
	public Token[] getTokens(){
		return tokens;
	}
	
	@Override
	public String[] getErrors(){
		return errors;
	}
	
	@Override
	public ClearableHistoryInterface getTokenList(){
		return tokenList;
	}
	
	/**
	 * Produces output from each string
	 */
	private void scanString(String s){
		
		// Reset arrays
		numTokens = 0;
		numErrors = 0;
		tokenList.clear();
		
		Iterator<String> iterator = new ScanningIterator(s);
		
		Token tokenObject = null;	// used to grab each token
		
		// Take each space-delimited token
		while (iterator.hasNext()){
			String tokenString = iterator.next();

			boolean valid = true; // will be used to mark invalid tokens
			
			// Check for number
			if (Character.isDigit(tokenString.charAt(0))){
				valid = isValidNumber(tokenString);
				if (valid){
					tokenList.addElement(new NumberToken(tokenString));
					tokenObject = new NumberToken(tokenString);
				}
				
			// Check for word
			} else if (Character.isLetter(tokenString.charAt(0))){
				valid = isValidWord(tokenString);
				if (valid){
					tokenObject = constructCommandOrWord(tokenString);
				}
			
			// Check for quoted string
			} else if (tokenString.charAt(0) == '\"'){
				
				// The only invalid token would be an empty quoted string
				if (tokenString.length() <= "\"\"".length()){
					valid = false;
				}
				
				if (valid){
					
					// Trim quotation marks off the ends of the token
					tokenString = tokenString.substring(1, tokenString.length()-1);

					tokenList.addElement(new QuoteToken(tokenString));
					tokenObject = new QuoteToken(tokenString);
				}
			
			// Check for plus token
			} else if ("+".equals(tokenString)){
				tokenList.addElement(new PlusToken(tokenString));
				tokenObject = new PlusToken(tokenString);
			
			// Check for minus token
			} else if ("-".equals(tokenString)){
				tokenList.addElement(new MinusToken(tokenString));
				tokenObject = new MinusToken(tokenString);
			
			// Check for "start" token
			} else if ("{".equals(tokenString)){
				tokenList.addElement(new StartToken(tokenString));
				tokenObject = new StartToken(tokenString);
				
			// Check for "end" token
			} else if ("}".equals(tokenString)){
				tokenList.addElement(new EndToken(tokenString));
				tokenObject = new EndToken(tokenString);
				
			// Otherwise invalid
			} else{
				valid = false;
			}
			
			if (valid){
				tokenStorage[numTokens] = tokenObject;
				++numTokens;
			} else {
				errorStorage[numErrors] = tokenString;
				++numErrors;
			}
		}//end grabbing tokens
		
		// Compress arrays
		tokens = new Token[numTokens];
		for (int i = 0; i < numTokens; ++i){
			tokens[i] = tokenStorage[i];
		}
		
		errors = new String[numErrors];
		for (int i = 0; i < numErrors; ++i){
			errors[i] = errorStorage[i];
		}
	}//end scanString()
	
	/**
	 * Constructs proper command from word, or just a word if no command matches.
	 * Assumes that word is non-empty and valid.
	 * From A6 onward, also stores a copy of the token in tokenList.
	 * 
	 * @param tokenString
	 * @return proper command object, or word object otherwise
	 */
	private Token constructCommandOrWord(String tokenString) {
		
		if ("approach".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new ApproachCommandToken(tokenString));
			return new ApproachCommandToken(tokenString);
			
		}else if ("fail".equalsIgnoreCase(tokenString)){

			tokenList.addElement(new FailCommandToken(tokenString));
			return new FailCommandToken(tokenString);
			
		}else if ("move".equalsIgnoreCase(tokenString)){

			tokenList.addElement(new MoveCommandToken(tokenString));
			return new MoveCommandToken(tokenString);
			
		}else if ("pass".equalsIgnoreCase(tokenString)){

			tokenList.addElement(new PassCommandToken(tokenString));
			return new PassCommandToken(tokenString);
			
		}else if ("repeat".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new RepeatCommandToken(tokenString));
			return new RepeatCommandToken(tokenString);
			
		}else if ("say".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new SayCommandToken(tokenString));
			return new SayCommandToken(tokenString);
			
		}else if ("call".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new CallCommandToken(tokenString));
			return new CallCommandToken(tokenString);
			
		}else if ("define".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new DefineCommandToken(tokenString));
			return new DefineCommandToken(tokenString);
			
		}else if ("proceedall".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new ProceedAllCommandToken(tokenString));
			return new ProceedAllCommandToken(tokenString);
			
		}else if ("redo".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new RedoCommandToken(tokenString));
			return new RedoCommandToken(tokenString);
			
		}else if ("rotateleftarm".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new RotateLeftArmCommandToken(tokenString));
			return new RotateLeftArmCommandToken(tokenString);
			
		}else if ("rotaterightarm".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new RotateRightArmCommandToken(tokenString));
			return new RotateRightArmCommandToken(tokenString);
			
		}else if ("sleep".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new SleepCommandToken(tokenString));
			return new SleepCommandToken(tokenString);
			
		}else if ("thread".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new ThreadCommandToken(tokenString));
			return new ThreadCommandToken(tokenString);
			
		}else if ("undo".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new UndoCommandToken(tokenString));
			return new UndoCommandToken(tokenString);
			
		}else if ("wait".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new WaitCommandToken(tokenString));
			return new WaitCommandToken(tokenString);
		}
		
		// If none matched, return generic word
		tokenList.addElement(new WordToken(tokenString));
		return new WordToken(tokenString);
	}

	private static boolean isValidWord(String s){
		
		// Assume correct to begin with
		boolean validity = true;
		
		// Go through and stop at any invalid character
		for (int i = 0; i < s.length(); ++i){
			if (!Character.isLetter(s.charAt(i))){
				validity = false;
				break;
			}
		}
		return validity;
	}
	
	private static boolean isValidNumber(String s){
		
		// Assume correct to begin with
		boolean validity = true;
		
		// Go through and stop at any invalid character
		for (int i = 0; i < s.length(); ++i){
			if (!Character.isDigit(s.charAt(i))){
				validity = false;
				break;
			}
		}
		return validity;
	}
}//end class
//END OF FILE
//START OF FILE: src/grail/scanner/scanningiterator.java
package grail.scanner;

import java.util.Iterator;

public class ScanningIterator implements Iterator<String>{

	private String stringData;
	private int position = 0;
	
	/**
	 * Constructor
	 * @param s string to iterate over
	 */
	public ScanningIterator(String s){
		stringData = s;
	}

	/**
	 * Checks whether there is another token to be had
	 */
	@Override
	public boolean hasNext() {
		
		// Consume spaces
		position = indexOfNot(stringData, ' ', position);
		if (position == -1){
			position = stringData.length();
		}
		return (position < stringData.length());
	}

	/**
	 * Gets the next token
	 */
	@Override
	public String next() {
		
		// Consume spaces
		position = indexOfNot(stringData, ' ', position);
		if (position == -1){
			
			// Rest of string was spaces
			position = stringData.length();
			return "";
		}
		
		// Get token
		int tokenStart = position;
		int tokenEnd = position;
		
		// Treat quoted strings differently
		if (stringData.charAt(tokenStart) == '\"'){
			
			// Look for the closing quote after this quote
			tokenEnd = indexOf(stringData, '\"', tokenStart + 1);
			
			if (tokenEnd == -1){
				System.out.println("ERROR: No closing quote found. Assumed line end to be closing quote.");
				tokenEnd = stringData.length();
				position = tokenEnd;
				return stringData.substring(tokenStart, tokenEnd)+ "\"";
			
			// If closing quote exists, make sure it is grabbed
			} else {
				++tokenEnd;
			}
			
		// If not a quoted string, end of token is a space or line end	
		} else {
			tokenEnd = indexOf(stringData, ' ', tokenStart);
		}
			
		if (tokenEnd == -1){
			tokenEnd = stringData.length();
		}
		
		position = tokenEnd;
		
		return stringData.substring(tokenStart, tokenEnd);
	}
	
	/**
	 * Returns index of first character equal to ch
	 * @param s
	 * @param ch
	 * @param fromIndex index at which to start search
	 * @return index of first ocurrence of ch after fromIndex, or -1 if not found
	 */
	private static int indexOf(String s, char ch, int fromIndex){
		for (int i=fromIndex; i < s.length(); ++i){
			if (s.charAt(i)==ch){
				return i;
			}
		}
		return -1;
	}

	/**
	 * Returns index of first character not equal to ch
	 * 
	 * @param s
	 * @param ch
	 * @param fromIndex index at which to start search
	 * @return index of first character that is not ch after fromIndex, or -1 if no non-ch characters found
	 */
	private static int indexOfNot(String s, char ch, int fromIndex){
		for (int i=fromIndex; i < s.length(); ++i){
			if (s.charAt(i)!=ch){
				return i;
			}
		}
		return -1;
	}

}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/movecommand.java
package grail.scanner.commands;

import grail.interfaces.AvatarInterface;
import grail.interfaces.CommandThread;
import util.annotations.Tags;

@Tags({"MoveCommand"})
public class MoveCommand implements CommandThread{

	private AvatarInterface avatar;
	private int xOffset;
	private int yOffset;
	
	public MoveCommand(AvatarInterface avatar, int xOffset, int yOffset){
		this.avatar = avatar;
		this.xOffset = xOffset;
		this.yOffset = yOffset;
	}
	
	@Override
	public void run() {
		avatar.move(xOffset, yOffset);
	}

}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/saycommand.java
package grail.scanner.commands;

import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandThread;
import util.annotations.Tags;

@Tags({"SayCommand"})
public class SayCommand implements CommandThread{

	private BridgeSceneInterface scene;
	private String quote;
	
	public SayCommand(BridgeSceneInterface scene, String quote){
		this.scene = scene;
		this.quote = quote;
	}
	
	@Override
	public void run() {
		scene.say(quote);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/endtoken.java
package grail.tokenBeans;

import util.annotations.EditablePropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"End"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@EditablePropertyNames({"Input"})
public class EndToken extends GenericToken {

	public EndToken(String input){
		super(input);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/generictoken.java
package grail.tokenBeans;

import grail.interfaces.Token;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;


@Tags({"Token"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input"})
@EditablePropertyNames({"Input"})
public class GenericToken implements Token{
	private String input;
		
	public GenericToken(String input){
		setInput(input);
	}
	
	@Override
	public void setInput(String newString) {
		input = newString;
	}

	@Override
	public String getInput() {
		return input;
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/minustoken.java
package grail.tokenBeans;

import util.annotations.EditablePropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Minus"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@EditablePropertyNames({"Input"})
public class MinusToken extends GenericToken {

	public MinusToken(String input){
		super(input);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/numbertoken.java
package grail.tokenBeans;

import grail.interfaces.Number;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Number"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class NumberToken extends GenericToken implements Number{
	
	private int value;
	
	public NumberToken(String input){
		super(input);
		value = Integer.parseInt(input);
	}
	
	@Override
	public void setInput(String newString) {
		super.setInput(newString);
		value = Integer.parseInt(newString);
	}

	@Override
	public int getValue() {
		return value;
	}
}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/plustoken.java
package grail.tokenBeans;

import util.annotations.EditablePropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Plus"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@EditablePropertyNames({"Input"})
public class PlusToken extends GenericToken {

	public PlusToken(String input){
		super(input);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/quotetoken.java
package grail.tokenBeans;

import util.annotations.EditablePropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Quote"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@EditablePropertyNames({"Input"})
public class QuoteToken extends GenericToken{

	public QuoteToken(String input){
		super(input);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/starttoken.java
package grail.tokenBeans;

import util.annotations.EditablePropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Start"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@EditablePropertyNames({"Input"})
public class StartToken extends GenericToken{
	
	public StartToken(String input){
		super(input);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/wordtoken.java
package grail.tokenBeans;

import grail.interfaces.Word;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Word"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class WordToken extends GenericToken implements Word{

	private String value;
	
	public WordToken(String input){
		super(input);
		value = input.toLowerCase();
	}
	
	@Override
	public void setInput(String newString) {
		super.setInput(newString);
		value = newString.toLowerCase();
	}

	@Override
	public String getValue() {
		return value;
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/commandbeans/approachcommandtoken.java
package grail.tokenBeans.commandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Approach"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class ApproachCommandToken extends WordToken {

	public ApproachCommandToken(String input) {
		super(input);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/commandbeans/failcommandtoken.java
package grail.tokenBeans.commandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Fail"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class FailCommandToken extends WordToken {

	public FailCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/commandbeans/movecommandtoken.java
package grail.tokenBeans.commandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Move"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class MoveCommandToken extends WordToken {

	public MoveCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/commandbeans/passcommandtoken.java
package grail.tokenBeans.commandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Pass"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class PassCommandToken extends WordToken {

	public PassCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/commandbeans/repeatcommandtoken.java
package grail.tokenBeans.commandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Repeat"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class RepeatCommandToken extends WordToken {

	public RepeatCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/commandbeans/saycommandtoken.java
package grail.tokenBeans.commandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Say"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class SayCommandToken extends WordToken {

	public SayCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/callcommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Call"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class CallCommandToken extends WordToken {

	public CallCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/definecommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Define"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class DefineCommandToken extends WordToken {

	public DefineCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/proceedallcommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"ProceedAll"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class ProceedAllCommandToken extends WordToken {

	public ProceedAllCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/redocommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Redo"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class RedoCommandToken extends WordToken {

	public RedoCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/rotateleftarmcommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"RotateLeftArm"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class RotateLeftArmCommandToken extends WordToken {

	public RotateLeftArmCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/rotaterightarmcommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"RotateRightArm"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class RotateRightArmCommandToken extends WordToken {

	public RotateRightArmCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/sleepcommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Sleep"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class SleepCommandToken extends WordToken {

	public SleepCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/threadcommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Thread"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class ThreadCommandToken extends WordToken {

	public ThreadCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/undocommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Undo"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class UndoCommandToken extends WordToken {

	public UndoCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/waitcommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Wait"})@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class WaitCommandToken extends WordToken {

	public WaitCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/main/assignment10.java
package main;

import java.awt.Component;
import java.beans.PropertyChangeListener;

import javax.swing.JFrame;
import javax.swing.JProgressBar;

import grail.SingletonsCreator;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandInterpreterInterface;
import grail.interfaces.mvc.CommandInterpreterControllerInterface;
import grail.interfaces.mvc.CommandInterpreterViewInterface;
import grail.interfaces.mvc.DelegatingBridgeSceneViewInterface;
import grail.interfaces.mvc.PaintingViewMaster;
import grail.mvc.view.CommandInterpreterView;
import grail.mvc.view.ConsoleSceneView;
import util.annotations.Tags;
import util.misc.ThreadSupport;

@Tags({"ProgressBarCreator"})
public class Assignment10 {

		private static JProgressBar progressBar;
		private static final int BAR_ROWS = 1;
		private static final int BAR_COLUMNS = 1;
		private static final int BAR_WIDTH = 500;
		private static final int BAR_HEIGHT = 100;
		
		private static final int PROGRESS_BAR_MAX = 100;
		private static final int BAR_INCREMENT = 25;
		
		private static final int LONG_DELAY = 1500;

		private static final int OEFRAME_WIDTH = 1000;
		private static final int OEFRAME_HEIGHT = 500;
		
		private static final int SCENE_VIEW_WIDTH = 1500;
		private static final int SCENE_VIEW_HEIGHT = 500;
		
		private static final int INTERPRETER_VIEW_WIDTH = 300;
		private static final int INTERPRETER_VIEW_HEIGHT = 300;
		
		private static final int INTERPRETER_OE_WIDTH = 300;
		private static final int INTERPRETER_OE_HEIGHT = 500;
		
		private static final String SAY_COMMAND = "say \"Hello!\"";

		
		public static void main(String[] args) throws InterruptedException {
			// Model
			BridgeSceneInterface scene = SingletonsCreator.bridgeSceneFactoryMethod();
			
			// Painting view
			DelegatingBridgeSceneViewInterface sceneView = SingletonsCreator.delegatingBridgeSceneViewFactoryMethod();
			PaintingViewMaster sceneViewComponent = SingletonsCreator.observableBridgeScenePainterFactoryMethod();
			
			JFrame sceneFrame = new JFrame("Bridge Scene");
			sceneFrame.add((Component)sceneViewComponent);
			sceneFrame.setSize(SCENE_VIEW_WIDTH, SCENE_VIEW_HEIGHT);
			sceneFrame.setVisible(true);
			
			// Console view
			PropertyChangeListener consoleView = new ConsoleSceneView();
			
			
			// Command Interpreter:
			// Model
			CommandInterpreterInterface commandInterpreter = SingletonsCreator.commandInterpreterFactoryMethod();
			
			// View
			CommandInterpreterViewInterface interpreterView = SingletonsCreator.commandInterpreterViewFactoryMethod();
			JFrame interpreterFrame = (CommandInterpreterView)interpreterView;
			interpreterFrame.setSize(INTERPRETER_VIEW_WIDTH, INTERPRETER_VIEW_HEIGHT);
			interpreterFrame.setVisible(true);
			
			// Controller
			CommandInterpreterControllerInterface interpreterController = SingletonsCreator.commandInterpreterControllerFactoryMethod();
			
			
			// Demo
			ThreadSupport.sleep(LONG_DELAY);
			scene.approach(scene.getLancelot());
			ThreadSupport.sleep(LONG_DELAY);
			commandInterpreter.setCommand(SAY_COMMAND);
			ThreadSupport.sleep(LONG_DELAY);
			commandInterpreter.setCommand(SAY_COMMAND);
			ThreadSupport.sleep(LONG_DELAY);
			scene.passed();
			ThreadSupport.sleep(LONG_DELAY);
			
			// Animations
			commandInterpreter.animateArthur();
			commandInterpreter.animateGalahad();
			commandInterpreter.animateLancelot();
			commandInterpreter.animateRobin();
			commandInterpreter.clapGuard();
			
		}//end main
		
		public static JProgressBar getProgressBar(){
			return progressBar;
		}
}//end class
//END OF FILE
