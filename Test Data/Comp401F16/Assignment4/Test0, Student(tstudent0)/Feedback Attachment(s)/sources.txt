//START OF FILE: src/grail/apolarpoint.java
package grail;
import util.annotations.WebDocuments;

//@WebDocuments({"Lectures/Graphics.pptx", "Lectures/Graphics.pdf", "Videos/Graphics.avi"})
public class APolarPoint implements Point {
    double radius, angle;
    public APolarPoint(double theRadius, double theAngle) {
        radius = theRadius;
        angle = theAngle;
    }
    public APolarPoint(int theX, int theY) {
        radius = Math.sqrt(theX*theX + theY*theY);
        angle = Math.atan((double) theY/theX);
    }
    public int getX() { return (int) (radius*Math.cos(angle)); }
    public int getY() { return (int) (radius*Math.sin(angle)); }
    public double getAngle() { return angle; } 
    public double getRadius() { return radius;} 
}
//END OF FILE
//START OF FILE: src/grail/beanstringscanner.java
package grail;
//this is for assignment2, so I donot implement interfaces
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;


@Tags({"BeanStringScanner"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"scannedString"})
@EditablePropertyNames({"scannedString"})

public class BeanStringScanner {
	private String scannedString;
	
	public void setScannedString(String str)
	{
		scannedString=str;
		scanString(str);
	}
	public String getScannedString(){
		return scannedString;
	}
	
	private void scanString(String line)
	{
		
		char c; 
		int quota=0;// to remember the number of quotas
		int flag=0;//word:1, number:2
		StringBuffer word=new StringBuffer();
		
		String numberPreToken="number: ";
		String wordPreToken="word: ";
		String signPreToken="sign: ";
		 for (int i=0;i<line.length();i++)
		 {
			 c=line.charAt(i);
			 if (c=='"')
			 {
				 quota++;
				 if(quota==2)//output word
				 {
					 System.out.println("quoted string: "+word);
					 word.delete(0,word.length());
					 flag=0;
					 quota=0;
				 }else if (quota==1)
				 {
					//donothing, not allow word or number to output
				 }else
				 {
					 continue;
				 }
			 }
			 else if (Character.isDigit(c))
			 {
				 flag=1;
				 word.append(c);
			 }
			 else if (Util.isLetter(c))
			 {
				 flag=2;
				 word.append(c); 
			 }
			 else if(c==' ')
			 {
				 if (quota==1)
				 {
					 word.append(c);
					 continue;
				 }
				 if (flag==1){
					 int num=Integer.parseInt(word.toString());
					 System.out.println(numberPreToken+num);
					 flag=0;
					 word.delete(0, word.length());
				 }
				 else if (flag==2)
				 {
					 System.out.println(wordPreToken+word);
					 flag=0;
					 word.delete(0, word.length());
				 }else//continuous space after word 
				 {
					 continue;
				 }
			 }
			 else if (c=='+'||c=='-')//we should also ouput "+" or "-"
			 {
				 if (quota==1)
				 {
					 word.append(c);
					 continue;
				 }
				 if (flag==1){
					 int num=Integer.parseInt(word.toString());
					 System.out.println(numberPreToken+num);
					 System.out.println(signPreToken+c);
					 flag=0;
					 word.delete(0, word.length());
				 }
				 else if (flag==2)
				 {
					 System.out.println(wordPreToken+word);
					 System.out.println(signPreToken+c);
					 flag=0;
					 word.delete(0, word.length());
				 }else//continuous space after word 
				 {
					 continue;
				 }
			 }
			 else//other character, for example, symbols
			 {
				word.append(c);
			 }
		 }
		if (quota==1)
		{
			System.out.println("closed quota is missing.....");
			System.out.println(word);
		}
		else//output the last word
		{
			 if (flag==1){
				 int num=Integer.parseInt(word.toString());
				 System.out.println(numberPreToken+num);
				 flag=0;
				 word.delete(0, word.length());
			 }
			 else if (flag==2)
			 {
				 System.out.println(wordPreToken+word);
				 flag=0;
				 word.delete(0, word.length());
			 }
		}
	}

}
//END OF FILE
//START OF FILE: src/grail/beanstringscanner4.java
package grail;
//this is for assignment4


import mp.EndToken;
import mp.Number;
import mp.Minus;
import mp.Plus;
import mp.ProcNumberValue;
import mp.QuotedString;
import mp.RawInput;
import mp.StartToken;
import mp.Word;
import mp.ProcWordValue;

import mp.Move;
import mp.Say;
import mp.RotateLeftArm;
import mp.RotateRightArm;
import mp.Repeat;
import mp.Define;
import mp.Call;
import mp.Thread;
import mp.Wait;
import mp.ProceedAll;
import mp.Sleep;
import mp.Undo;
import mp.Redo;

import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"ScannerBean"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"scannedString","tokens","errLog"})
@EditablePropertyNames({"scannedString"})

public class BeanStringScanner4 implements ScannerInterface{
	private String scannedString;
	private RawInput[] largeTokenArray;//not a property
	private RawInput[] tokens;//read-only property
	private final int maxNUM=100;
	String errLog="";
	private int cnt;
	public BeanStringScanner4()
	{
		//create large array
		//largeTokenArray=new RawInput[maxNUM];//but you have to instantiate it for every specific token 
	}
	public void setScannedString(String str)
	{
		errLog="";
		scannedString=str;
		largeTokenArray=new RawInput[str.length()];//but you have to instantiate it for every specific token 
		
		scanString(str);
		
		tokens=new RawInput[cnt];//instantiate for each specific token
		for (int i=0;i<cnt;i++)
		{
			tokens[i]=largeTokenArray[i];
		}
		//create compact array
		
	}
	
	public String getScannedString(){
		return scannedString;
	}
	public RawInput[] getTokens()
	{
		return tokens;
	}
	public String getErrLog()
	{
		return errLog;
	}
	
	public void scanString(String line)
	{
		
		char c; 
		int quota=0;// to remember the number of quotas
		int flag=0;//word:1, number:2
		//StringBuffer word=new StringBuffer();
		String word="";
		cnt=0;//to count number of real tokens, it is a global variable
		 for (int i=0;i<line.length();i++)
		 {
			 c=line.charAt(i);
			 if (c=='"')
			 {
				 quota++;
				 if(quota==2)//output word
				 {
					 //do new operation as required in Assignment3
					 RawInput qs=new QuotedString(word);
					 //System.out.println(qs);
					 //System.out.println(qs.getInput());
					 largeTokenArray[cnt++]=qs;
					 word="";
					 //word.delete(0,word.length());
					 flag=0;
					 quota=0;
				 }else if (quota==1)
				 {
					//donothing, not allow word or number to output
				 }else
				 {
					 continue;
				 }
			 }
			 else if (Character.isDigit(c))
			 {
				 flag=1;
				 word+=c;
				 //word.append(c);
			 }
			 else if (Util.isLetter(c))
			 {
				 flag=2;
				 word+=c;
				 //word.append(c); 
			 }
			 else if (c=='{'&&quota==0)
			 {
				 RawInput st=new StartToken(Util.char2String(c));
				 largeTokenArray[cnt++]=st;

				 //System.out.println(st);
				 //System.out.println(st.getInput());
			 }
			 else if (c=='}'&&quota==0)
			 {
				 RawInput et=new EndToken(Util.char2String(c));
				 largeTokenArray[cnt++]=et;

				 //System.out.println(et);
				 //System.out.println(et.getInput());
			 }
			 else if(c==' ')
			 {
				 if (quota==1)
				 {
					 //word.append(c);
					 word+=c;
					 continue;
				 }
				 if (flag==1){
					//do new operation as required in Assignment3
					 RawInput num=new Number(word);
					 largeTokenArray[cnt++]=num;
					 //System.out.println(num);
					 //System.out.println(num.getInput());
					 //ProcNumberValue pnv=new Number(word);
					 //System.out.println(pnv.getValue());
				
					 flag=0;
					 word="";
					 //word.delete(0, word.length());
				 }
				 else if (flag==2)//input a word
				 {
					//do new operation as required in Assignment3
					 //RawInput ww=new Word(word);
					 RawInput ww=subWordConverter(word);
					 largeTokenArray[cnt++]=ww;
					 //System.out.println(ww);
					 //System.out.println(ww.getInput());
					 //ProcWordValue pwv=new Word(word);
					 //System.out.println(pwv.getValue());
					 flag=0;
					 word="";
					 //word.delete(0, word.length());
				 }else//continuous space after word 
				 {
					 continue;
				 }
			 }
			 else if (c=='+'||c=='-')//we should also ouput "+" or "-"
			 {
				 if (quota==1)
				 {
					 word+=c;
					 //word.append(c);
					 continue;
				 }
				 if (flag==1){
					//do new operation as required in Assignment3
					 RawInput num=new Number(word);
					 largeTokenArray[cnt++]=num;
					 /*
					 System.out.println(num);
					 System.out.println(num.getInput());
					 ProcNumberValue pnv=new Number(word);
					 System.out.println(pnv.getValue());
				*/
					 //int num=Integer.parseInt(word.toString());
					 //System.out.println("number: "+num);
					 //System.out.println("sign: "+c);
					 /*
					if (c=='+')
					{
					
						RawInput pl=new Plus(Util.char2String(c));
						largeTokenArray[cnt++]=pl;
						//System.out.println(pl);
						//System.out.println(pl.getInput());
						
					}else
					{
						RawInput pl=new Minus(Util.char2String(c));
						 largeTokenArray[cnt++]=pl;
						//System.out.println(pl);
						//System.out.println(pl.getInput());
					}*/
					flag=0;
					word="";
					 //word.delete(0, word.length());
				 }
				 else if (flag==2)//input is a Word
				 {
					 //RawInput ww=new Word(word);
					 //System.out.println(ww);
					 //System.out.println(ww.getInput());
					 //ProcWordValue pwv=new Word(word);
					 //System.out.println(pwv.getValue());
					 RawInput ww=subWordConverter(word);
					 largeTokenArray[cnt++]=ww;
					 /*
					 if (c=='+')
					{
						RawInput pl=new Plus(Util.char2String(c));
						 largeTokenArray[cnt++]=pl;
						//System.out.println(pl);
						//System.out.println(pl.getInput());
						
					}else
					{
						RawInput pl=new Minus(Util.char2String(c));
						 largeTokenArray[cnt++]=pl;
						//System.out.println(pl);
						//System.out.println(pl.getInput());
					}*/
					 flag=0;
					 word="";
					 //word.delete(0, word.length());
				 }else//continuous space after word 
				 {
					 continue;
				 }
				 if (c=='+')
				 {
					RawInput pl=new Plus(Util.char2String(c));
				    largeTokenArray[cnt++]=pl;
					//System.out.println(pl);
					//System.out.println(pl.getInput());
						
				}else
				{
					RawInput pl=new Minus(Util.char2String(c));
					 largeTokenArray[cnt++]=pl;
					//System.out.println(pl);
					//System.out.println(pl.getInput());
				}
			 }
			 else//other character, for example, symbols
			 {
				 word+=c;
				//word.append(c);
			 }
		 }
		if (quota==1)
		{
			//System.out.println("closed quota is missing.....");
			errLog+="closed quota is missing...and the string is "+word+"\n";
			//System.out.println(word);
		}
		else//output the last word
		{
			 if (flag==1){
				 RawInput num=new Number(word);
				 //System.out.println(num);
				 //System.out.println(num.getInput());
				 //ProcNumberValue pnv=new Number(word);
				 //System.out.println(pnv.getValue());
				 largeTokenArray[cnt++]=num;

				 flag=0;
				 word="";
				 //word.delete(0, word.length());
			 }
			 else if (flag==2)//input is a Word
			 {
				 //RawInput ww=new Word(word);
				 //System.out.println(ww);
				 //System.out.println(ww.getInput());
				 //ProcWordValue pwv=new Word(word);
				 //System.out.println(pwv.getValue());
				 
				 RawInput ww=subWordConverter(word);
				 largeTokenArray[cnt++]=ww;
				 flag=0;
				 word="";
				 //word.delete(0, word.length());
			 }
		}
	}
	
	//this method returns the specific word object: move->Move...
	private RawInput subWordConverter(String word)
	{
		RawInput ww=null;
		String temp=word.toLowerCase();
		switch (temp){
		case "move":
			ww=new Move(word);
			break;
		case "say":
			ww=new Say(word);
			break;
		case "rotateleftarm":
			ww=new RotateLeftArm(word);
			break;
		case "rotaterightarm":
			ww=new RotateRightArm(word);
			break;
		case "repeat":
			ww=new Repeat(word);
			break;
		case "define":
			ww=new Define(word);
			break;
		case "call":
			ww=new Call(word);
			break;
		case "thread":
			ww=new Thread(word);
			break;
		case "wait":
			ww=new Wait(word);
			break;
		case "proceedall":
			ww=new ProceedAll(word);
			break;
		case "sleep":
			ww=new Sleep(word);
			break;
		case "undo":
			ww=new Undo(word);
			break;
		case "redo":
			ww=new Redo(word);
			break;
		default:
			ww= new Word(word);
			break;
		}
		return ww;
	}

}
//END OF FILE
//START OF FILE: src/grail/extbeanstringscanner.java
package grail;
//this is a expansion version for assignment3
import mp.EndToken;
import mp.Number;
import mp.Minus;
import mp.Plus;
import mp.ProcNumberValue;
import mp.QuotedString;
import mp.RawInput;
import mp.StartToken;
import mp.Word;
import mp.ProcWordValue;

import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"ExtBeanStringScanner"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"scannedString"})
@EditablePropertyNames({"scannedString"})

//public class ExtBeanStringScanner implements ScannerInterface{//because I have modified the scannerInterface 
public class ExtBeanStringScanner{
	private String scannedString;
	
	public void setScannedString(String str)
	{
		scannedString=str;
		scanString(str);
	}
	public String getScannedString(){
		return scannedString;
	}
	
	public void scanString(String line)
	{
		
		char c; 
		int quota=0;// to remember the number of quotas
		int flag=0;//word:1, number:2
		//StringBuffer word=new StringBuffer();
		String word="";
		 for (int i=0;i<line.length();i++)
		 {
			 c=line.charAt(i);
			 if (c=='"')
			 {
				 quota++;
				 if(quota==2)//output word
				 {
					 //do new operation as required in Assignment3
					 RawInput qs=new QuotedString(word);
					 System.out.println(qs);
					 System.out.println(qs.getInput());
					 word="";
					 //word.delete(0,word.length());
					 flag=0;
					 quota=0;
				 }else if (quota==1)
				 {
					//donothing, not allow word or number to output
				 }else
				 {
					 continue;
				 }
			 }
			 else if (Character.isDigit(c))
			 {
				 flag=1;
				 word+=c;
				 //word.append(c);
			 }
			 else if (Util.isLetter(c))
			 {
				 flag=2;
				 word+=c;
				 //word.append(c); 
			 }
			 else if (c=='{'&&quota==0)
			 {
				 RawInput st=new StartToken(Util.char2String(c));
				 System.out.println(st);
				 System.out.println(st.getInput());
			 }
			 else if (c=='}'&&quota==0)
			 {
				 RawInput et=new EndToken(Util.char2String(c));
				 System.out.println(et);
				 System.out.println(et.getInput());
			 }
			 else if(c==' ')
			 {
				 if (quota==1)
				 {
					 //word.append(c);
					 word+=c;
					 continue;
				 }
				 if (flag==1){
					//do new operation as required in Assignment3
					 RawInput num=new Number(word);
					 System.out.println(num);
					 System.out.println(num.getInput());
					 ProcNumberValue pnv=new Number(word);
					 System.out.println(pnv.getValue());
				
					 flag=0;
					 word="";
					 //word.delete(0, word.length());
				 }
				 else if (flag==2)
				 {
					//do new operation as required in Assignment3
					 RawInput ww=new Word(word);
					 System.out.println(ww);
					 System.out.println(ww.getInput());
					 ProcWordValue pwv=new Word(word);
					 System.out.println(pwv.getValue());
					 flag=0;
					 word="";
					 //word.delete(0, word.length());
				 }else//continuous space after word 
				 {
					 continue;
				 }
			 }
			 else if (c=='+'||c=='-')//we should also ouput "+" or "-"
			 {
				 if (quota==1)
				 {
					 word+=c;
					 //word.append(c);
					 continue;
				 }
				 if (flag==1){
					//do new operation as required in Assignment3
					 RawInput num=new Number(word);
					 System.out.println(num);
					 System.out.println(num.getInput());
					 ProcNumberValue pnv=new Number(word);
					 System.out.println(pnv.getValue());
				
					 //int num=Integer.parseInt(word.toString());
					 //System.out.println("number: "+num);
					 //System.out.println("sign: "+c);
					if (c=='+')
					{
					
						RawInput pl=new Plus(Util.char2String(c));
						System.out.println(pl);
						System.out.println(pl.getInput());
						
					}else
					{
						RawInput pl=new Minus(Util.char2String(c));
						System.out.println(pl);
						System.out.println(pl.getInput());
					}
					flag=0;
					word="";
					 //word.delete(0, word.length());
				 }
				 else if (flag==2)
				 {
					 RawInput ww=new Word(word);
					 System.out.println(ww);
					 System.out.println(ww.getInput());
					 ProcWordValue pwv=new Word(word);
					 System.out.println(pwv.getValue());
					 
					 if (c=='+')
					{
						RawInput pl=new Plus(Util.char2String(c));
						System.out.println(pl);
						System.out.println(pl.getInput());
						
					}else
					{
						RawInput pl=new Minus(Util.char2String(c));
						System.out.println(pl);
						System.out.println(pl.getInput());
					}
					 flag=0;
					 word="";
					 //word.delete(0, word.length());
				 }else//continuous space after word 
				 {
					 continue;
				 }
			 }
			 else//other character, for example, symbols
			 {
				 word+=c;
				//word.append(c);
			 }
		 }
		if (quota==1)
		{
			System.out.println("closed quota is missing.....");
			System.out.println(word);
		}
		else//output the last word
		{
			 if (flag==1){
				 RawInput num=new Number(word);
				 System.out.println(num);
				 System.out.println(num.getInput());
				 ProcNumberValue pnv=new Number(word);
				 System.out.println(pnv.getValue());

				 flag=0;
				 word="";
				 //word.delete(0, word.length());
			 }
			 else if (flag==2)
			 {
				 RawInput ww=new Word(word);
				 System.out.println(ww);
				 System.out.println(ww.getInput());
				 ProcWordValue pwv=new Word(word);
				 System.out.println(pwv.getValue());
				 flag=0;
				 word="";
				 //word.delete(0, word.length());
			 }
		}
	}

}
//END OF FILE
//START OF FILE: src/grail/line.java
package grail;

import util.annotations.Tags;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.LINE_PATTERN)
@Tags({"RotatingLine"})

//this is for assignment4

public class Line implements Shape{
	//width,height is the property of bounding box
    //x, y is the upper-left corner point of bounding box of the shape
    int x, y, width, height;
    double radius, angle;
    private final double degreePerUnit=Math.PI/32;
   // Point lrPoint;//for lower-right corner point
    
    //angle is in radian measurement, radian, angle
    public Line(double r, double a)
    {
    	radius=r;
    	angle=a;
    	height=(int)(r*Math.sin(a));
    	width=(int)(r*Math.cos(a));
    	//lrPoint=new APolarPoint(r,a);
    	//lrPoint.setX(x);
    }
    
    
    public void setRadius(double r)
    {
    	radius=r;
    	height=(int)(r*Math.sin(this.angle));
    	width=(int)(r*Math.cos(this.angle));

    }
    
    public void setAngle(double a)
    {
     	angle=a;
    	this.height=(int)(this.radius*Math.sin(this.angle));
    	this.width=(int)(this.radius*Math.cos(this.angle));
    	//System.out.println("height: "+height+"width: "+width);
    }
    
    public void setX(int x)
    {
    	this.x=x;
    }
    
    public void setY(int y)
    {
    	this.y=y;
    }
    public int getX()
    {
    	return x;
    }
    public int getY()
    {
    	return y;
    }
    public int getWidth()
    {
    	return width;
    }
    
    public int getHeight()
    {
    	return height;
    }
    

    @Tags({"rotate"})
    public void changeRotateAngle (int units) 
    {
    	double d=units*degreePerUnit;
    	this.setAngle(d);
    }
    
}
//END OF FILE
//START OF FILE: src/grail/point.java
package grail;
import util.annotations.WebDocuments;
import util.annotations.Explanation;
//@StructurePattern(StructurePatternNames.POINT_PATTERN)
//@Explanation("Location in Java coordinate System.")
//@WebDocuments({"Lectures/Graphics.pptx", "Lectures/Graphics.pdf", "Videos/Graphics.avi"})
public interface Point {
    public int getX(); 
    public int getY();  
    public double getAngle(); 
    public double getRadius(); 
}
//END OF FILE
//START OF FILE: src/grail/scannerinterface.java
package grail;

import mp.RawInput;

//this is for assignment3
public interface ScannerInterface {
	public void setScannedString(String str);
	public String getScannedString();
	public void scanString(String line);
	public RawInput[] getTokens();
	public String getErrLog();
}
//END OF FILE
//START OF FILE: src/grail/shape.java
package grail;

public interface Shape {
    public void setRadius(double r);
    public void setAngle(double a);
    public void setX(int x);
    public void setY(int y);
    public int getX();
    public int getY();
    public int getWidth();
    public int getHeight();
    public void changeRotateAngle (int units);


}
//END OF FILE
//START OF FILE: src/grail/stringscanner.java
package grail;
//this is for assignment2
public class StringScanner {

	public static void myScanner(String line)
	{
		
		char c; 
		int quota=0;// to remember the number of quotas
		int flag=0;//word:1, number:2
		StringBuffer word=new StringBuffer();
		
		String numberPreToken="number: ";
		String wordPreToken="word: ";
		String signPreToken="sign: ";
		 for (int i=0;i<line.length();i++)
		 {
			 c=line.charAt(i);
			 if (c=='"')
			 {
				 quota++;
				 if(quota==2)//output word
				 {
					 System.out.println("quoted string: "+word);
					 word.delete(0,word.length());
					 flag=0;
					 quota=0;
				 }else if (quota==1)
				 {
					//donothing, not allow word or number to output
				 }else
				 {
					 continue;
				 }
			 }
			 else if (Character.isDigit(c))
			 {
				 flag=1;
				 word.append(c);
			 }
			 else if (Character.isLetter(c))
			 {
				 flag=2;
				 word.append(c); 
			 }
			 else if(c==' ')
			 {
				 if (quota==1)
				 {
					 word.append(c);
					 continue;
				 }
				 if (flag==1){
					 int num=Integer.parseInt(word.toString());
					 System.out.println(numberPreToken+num);
					 flag=0;
					 word.delete(0, word.length());
				 }
				 else if (flag==2)
				 {
					 System.out.println(wordPreToken+word);
					 flag=0;
					 word.delete(0, word.length());
				 }else//continuous space after word 
				 {
					 continue;
				 }
			 }
			 else if (c=='+'||c=='-')//we should also ouput "+" or "-"
			 {
				 if (quota==1)
				 {
					 word.append(c);
					 continue;
				 }
				 if (flag==1){
					 int num=Integer.parseInt(word.toString());
					 System.out.println(numberPreToken+num);
					 System.out.println(signPreToken+c);
					 flag=0;
					 word.delete(0, word.length());
				 }
				 else if (flag==2)
				 {
					 System.out.println(wordPreToken+word);
					 System.out.println(signPreToken+c);
					 flag=0;
					 word.delete(0, word.length());
				 }else//continuous space after word 
				 {
					 continue;
				 }
			 }
			 else//other character, for example, symbols
			 {
				word.append(c);
			 }
		 }
		if (quota==1)
		{
			System.out.println("closed quota is missing.....");
			System.out.println(word);
		}
		else//output the last word
		{
			 if (flag==1){
				 int num=Integer.parseInt(word.toString());
				 System.out.println(numberPreToken+num);
				 flag=0;
				 word.delete(0, word.length());
			 }
			 else if (flag==2)
			 {
				 System.out.println(wordPreToken+word);
				 flag=0;
				 word.delete(0, word.length());
			 }
		}
	}
}
//END OF FILE
//START OF FILE: src/grail/util.java
package grail;

public class Util {
	public static boolean isLetter(char c)
	{
		return 'a'<=c&&c<='z'||'A'<=c&&c<='Z';
	}
	public static String char2String(char c)
	{
		String res="";
		res+=c;
		return res;
	}
}
//END OF FILE
//START OF FILE: src/main/assignment3.java
package main;

import grail.ExtBeanStringScanner;
import grail.ScannerInterface;

import java.util.Scanner;
/**
 * 
 * @author Dong Nie
 * dongnie@cs.unc.edu
 *
 *This is for assignment3 from comp 401
 */
public class Assignment3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("please enter a string:");
		Scanner scan = new Scanner(System.in);
		String line="";
		ScannerInterface bss=new ExtBeanStringScanner();
		while(true)
		{
		 line = scan.nextLine();
		// if(line.equals(""))
			// continue;
		 if (line.charAt(0)=='.')
		 {
			 break;
		 }
		 //System.out.println("Processed by ordinary class");
		 //StringScanner.myScanner(line); 
		 //System.out.println("Processed by bean class");
		 //test bean scanner
		 bss.setScannedString(line);
		}
	}

}
//END OF FILE
//START OF FILE: src/main/assignment4.java
package main;

import grail.BeanStringScanner4;
import grail.ScannerInterface;
import grail.Line;
import grail.Shape;

import java.util.Scanner;

import bus.uigen.ObjectEditor;
import bus.uigen.OEFrame;
import util.annotations.WebDocuments;
import util.misc.ThreadSupport;

//import lectures.animation.threads_commands.ThreadSupport;
/**
 * 
 * @author Dong Nie
 * dongnie@cs.unc.edu
 *
 *This is for assignment4 from comp 401
 */
public class Assignment4 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*
		System.out.println("please enter a string:");
		Scanner scan = new Scanner(System.in);
		String line="";
		
		while(true)
		{
		 line = scan.nextLine();
		// if(line.equals(""))
			// continue;
		 if (line.charAt(0)=='.')
		 {
			 break;
		 }
		 //System.out.println("Processed by ordinary class");
		 //StringScanner.myScanner(line); 
		 //System.out.println("Processed by bean class");
		 //test bean scanner
		 bss.setScannedString(line);
		 //ObjectEditor.edit(bss);
	     
		}*/
		final int intervalTime=3000;
		ScannerInterface bss=new BeanStringScanner4();

		 OEFrame oeFrame = ObjectEditor.edit(bss);
		 bss.setScannedString("MoVe 050 { saY \"hi!\" } ");
		 oeFrame.refresh();
		 ThreadSupport.sleep(intervalTime);
		 bss.setScannedString("RotateLeftArm 5 rotateLeftArm ");
		 oeFrame.refresh();
		 ThreadSupport.sleep(intervalTime); // 3 second delay should be enough
		 bss.setScannedString("Call Define 5 Turnleft ");
		 oeFrame.refresh();
		 ThreadSupport.sleep(intervalTime); // 3 second delay should be enough
		 
		 //set the x,y point
		 
		 final double rad=30,angle=1.71;
		 Shape sh=new Line(rad,angle);
		 oeFrame=ObjectEditor.edit(sh);
		 
		 //animate the movement
		 final int moveLen=550;
		 final int timeSleep=10;
		 for(int i = 0;i < moveLen; i++){
				ThreadSupport.sleep(timeSleep);	
				moveLine(sh,i);
				oeFrame.refresh();
			}
		 //animate rotation
			ThreadSupport.sleep(intervalTime);	
			oeFrame.refresh();
			final int coor=50;
			sh.setX(coor);
			sh.setY(coor);
		 int units=0;
		 for(int i = 0;i < moveLen; i++){
				ThreadSupport.sleep(timeSleep);
			 	units=i;
				rotateLine(sh,i+1);
				oeFrame.refresh();
			}
		 
		 //animate move and rotate
		 ThreadSupport.sleep(intervalTime);	
			oeFrame.refresh();
			sh.setX(coor);
			sh.setY(coor);
		 for(int i = 0;i < moveLen; i++){
				ThreadSupport.sleep(timeSleep);
			 	units=i;
			 	sh.setX(i);
				rotateLine(sh,i+1);
				oeFrame.refresh();
			}
	
	}
	
	/*rotate a line with different angles*/
	public static void rotateLine(Shape lineInstance, int units){
		lineInstance.changeRotateAngle(units);
	}
	
	/*move an object along the x axis*/
	public static void moveLine(Shape lineInstance, int x){
		lineInstance.setX(x); 
	}
}
//END OF FILE
//START OF FILE: src/mp/call.java
package mp;


import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Call"})

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input","value"})
@EditablePropertyNames({"input"})

public class Call extends Word {

	public Call(String input) {
		super(input);
		// TODO Auto-generated constructor stub
	}

}
//END OF FILE
//START OF FILE: src/mp/define.java
package mp;


import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Define"})

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input","value"})
@EditablePropertyNames({"input"})

public class Define extends Word {

	public Define(String input) {
		super(input);
		// TODO Auto-generated constructor stub
	}

}
//END OF FILE
//START OF FILE: src/mp/endtoken.java
package mp;

import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;


@Tags({"End"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input"})
@EditablePropertyNames({"input"})

public class EndToken implements RawInput{
	private String input="";
	
	public EndToken(String input)//need or not
	{
		this.input=input;
	}
	
	public void setInput(String input)
	{
		this.input=input;
	}
	
	public String getInput()
	{
		return this.input;
	}
}
//END OF FILE
//START OF FILE: src/mp/minus.java
package mp;

import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;


@Tags({"Minus"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input"})
@EditablePropertyNames({"input"})

public class Minus implements RawInput{
	private String input="";
	
	public Minus(String input)//need or not
	{
		this.input=input;
	}
	
	public void setInput(String input)
	{
		this.input=input;
	}
	
	public String getInput()
	{
		return this.input;
	}
}
//END OF FILE
//START OF FILE: src/mp/move.java
package mp;


import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Move"})

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input","value"})
@EditablePropertyNames({"input"})


public class Move extends Word{

	public Move(String str)
	{
		super(str);
	}
}
//END OF FILE
//START OF FILE: src/mp/number.java
package mp;

import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;


@Tags({"Number"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input","value"})
@EditablePropertyNames({"input"})

public class Number implements RawInput, ProcNumberValue{
	private String input="";
	private int value;
	
	public Number(String input)
	{
		this.input=input;
		value=Integer.parseInt(input);//the input not always legal, so need more process here
	}
	public void setInput(String input)
	{
		this.input=input;
		value=Integer.parseInt(input);//the input not always legal, so need more process here
	}
	
	public String getInput()
	{
		return this.input;
	}
	
	public int getValue()
	{
		return value;
	}
	
}
//END OF FILE
//START OF FILE: src/mp/plus.java
package mp;

import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;


@Tags({"Plus"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input"})
@EditablePropertyNames({"input"})

public class Plus implements RawInput{
	private String input="";
	
	public Plus(String input)//need or not
	{
		this.input=input;
	}
	
	public void setInput(String input)
	{
		this.input=input;
	}
	
	public String getInput()
	{
		return this.input;
	}
}
//END OF FILE
//START OF FILE: src/mp/procnumbervalue.java
package mp;

public interface ProcNumberValue {
	public int getValue();
}
//END OF FILE
//START OF FILE: src/mp/procwordvalue.java
package mp;

public interface ProcWordValue {
	public String getValue();
}
//END OF FILE
//START OF FILE: src/mp/proceedall.java
package mp;


import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"ProceedAll"})

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input","value"})
@EditablePropertyNames({"input"})

public class ProceedAll extends Word {

	public ProceedAll(String input) {
		super(input);
		// TODO Auto-generated constructor stub
	}

}
//END OF FILE
//START OF FILE: src/mp/quotedstring.java
package mp;

import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;


@Tags({"Quote"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input"})
@EditablePropertyNames({"input"})

public class QuotedString implements RawInput{
	private String input="";
	
	public QuotedString(String input)//need or not
	{
		this.input=input;
	}
	
	public void setInput(String input)
	{
		this.input=input;
	}
	
	public String getInput()
	{
		return this.input;
	}
}
//END OF FILE
//START OF FILE: src/mp/rawinput.java
package mp;

public interface RawInput {
	public void setInput(String input);
	public String getInput();
}
//END OF FILE
//START OF FILE: src/mp/redo.java
package mp;


import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Redo"})

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input","value"})
@EditablePropertyNames({"input"})

public class Redo extends Word {

	public Redo(String input) {
		super(input);
		// TODO Auto-generated constructor stub
	}

}
//END OF FILE
//START OF FILE: src/mp/repeat.java
package mp;


import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Repeat"})

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input","value"})
@EditablePropertyNames({"input"})

public class Repeat extends Word {

	public Repeat(String input) {
		super(input);
		// TODO Auto-generated constructor stub
	}

}
//END OF FILE
//START OF FILE: src/mp/rotateleftarm.java
package mp;

import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"RotateLeftArm"})

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input","value"})
@EditablePropertyNames({"input"})

public class RotateLeftArm extends Word{
	public RotateLeftArm(String str)
	{
		super(str);
	}
}
//END OF FILE
//START OF FILE: src/mp/rotaterightarm.java
package mp;


import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"RotateRightArm"})

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input","value"})
@EditablePropertyNames({"input"})

public class RotateRightArm extends Word{
	public RotateRightArm(String str)
	{
		super(str);
	}
}
//END OF FILE
//START OF FILE: src/mp/say.java
package mp;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Say"})

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input","value"})
@EditablePropertyNames({"input"})

public class Say extends Word{

	public Say(String str)
	{
		super(str);
	}
}
//END OF FILE
//START OF FILE: src/mp/sleep.java
package mp;



import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Sleep"})

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input","value"})
@EditablePropertyNames({"input"})

public class Sleep extends Word {

	public Sleep(String input) {
		super(input);
		// TODO Auto-generated constructor stub
	}

}
//END OF FILE
//START OF FILE: src/mp/starttoken.java
package mp;

import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;


@Tags({"Start"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input"})
@EditablePropertyNames({"input"})

public class StartToken implements RawInput{
	private String input="";
	
	public StartToken(String input)//need or not
	{
		this.input=input;
	}
	
	public void setInput(String input)
	{
		this.input=input;
	}
	
	public String getInput()
	{
		return this.input;
	}
}
//END OF FILE
//START OF FILE: src/mp/thread.java
package mp;



import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Thread"})

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input","value"})
@EditablePropertyNames({"input"})

public class Thread extends Word {

	public Thread(String input) {
		super(input);
		// TODO Auto-generated constructor stub
	}

}
//END OF FILE
//START OF FILE: src/mp/undo.java
package mp;



import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Undo"})

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input","value"})
@EditablePropertyNames({"input"})

public class Undo extends Word {

	public Undo(String input) {
		super(input);
		// TODO Auto-generated constructor stub
	}

}
//END OF FILE
//START OF FILE: src/mp/wait.java
package mp;


import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Wait"})

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input","value"})
@EditablePropertyNames({"input"})

public class Wait extends Word {

	public Wait(String input) {
		super(input);
		// TODO Auto-generated constructor stub
	}

}
//END OF FILE
//START OF FILE: src/mp/word.java
package mp;

import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;


@Tags({"Word"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"input","value"})
@EditablePropertyNames({"input"})

public class Word implements RawInput, ProcWordValue{
	private String input="";
	private String value;//lower case for the input string
	
	public Word(String input)
	{
		this.input=input;
		//value=input.toLowerCase();//the input not always legal, so need more process here
	}
	public void setInput(String input)
	{
		this.input=input;
		value=input.toLowerCase();//the input not always legal, so need more process here

		//value=input.toLowerCase();//the input not always legal, so need more process here
	}
	
	public String getInput()
	{
		return this.input;
	}
	
	public String getValue()
	{

		return value;
	}
	
}
//END OF FILE
