//START OF FILE: src/grail/singletonscreator.java
package grail;

import java.beans.PropertyChangeListener;

import grail.animations.fromJavaTeaching.ABroadcastingClearanceManager;
import grail.animations.fromJavaTeaching.BroadcastingClearanceManager;
import grail.collections.MoveCommandUndoer;
import grail.collections.MyTable;
import grail.graphics.BridgeScene;
import grail.interfaces.AvatarInterface;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandInterpreterInterface;
import grail.interfaces.CommandThread;
import grail.interfaces.ParserInterface;
import grail.interfaces.ScannerBeanInterface;
import grail.interfaces.Table;
import grail.interfaces.Undoer;
import grail.interfaces.mvc.BridgeSceneControllerInterface;
import grail.interfaces.mvc.CommandInterpreterControllerInterface;
import grail.interfaces.mvc.CommandInterpreterViewInterface;
import grail.interfaces.mvc.DelegatingBridgeSceneViewInterface;
import grail.interfaces.mvc.PaintingViewMaster;
import grail.mvc.controller.BridgeSceneController;
import grail.mvc.controller.CommandInterpreterController;
import grail.mvc.view.CommandInterpreterView;
import grail.mvc.view.ConsoleSceneView;
import grail.mvc.view.DelegatingBridgeSceneView;
import grail.mvc.view.ObservableBridgeScenePainter;
import grail.scanner.CommandInterpreter;
import grail.scanner.Parser;
import grail.scanner.ScannerBean;
import util.annotations.Tags;

@Tags({"SingletonsCreator"})
public class SingletonsCreator {
	
	private static ScannerBeanInterface scannerBean = null;
	private static BridgeSceneInterface bridgeScene = null;
	private static Table<AvatarInterface> avatarTable = null;
	private static Table<CommandThread> environment = null;

	private static CommandInterpreterInterface commandInterpreter = null;
	private static PropertyChangeListener consoleSceneView = null;
	private static PaintingViewMaster painter = null;
	private static DelegatingBridgeSceneViewInterface view = null;
	private static BridgeSceneControllerInterface mainControl = null;
	private static CommandInterpreterControllerInterface interpreterController = null;
	private static CommandInterpreterViewInterface interpreterView = null;
	private static ParserInterface parser = null;
	private static BroadcastingClearanceManager clearanceManager = null;
	private static Undoer undoer = null;
	
	public static Undoer undoerFactoryMethod(){
		if (null == undoer){
			undoer = new MoveCommandUndoer();
		}
		return undoer;
	}
	
	@Tags({"parserFactoryMethod"})
	public static ParserInterface parserFactoryMethod(){
		if (null == parser){
			parser = new Parser();
		}
		return parser;
	}
	
	@Tags({"commandInterpreterViewFactoryMethod"})
	public static CommandInterpreterViewInterface commandInterpreterViewFactoryMethod(){
		if (null == interpreterView){
			interpreterView = new CommandInterpreterView();
		}
		return interpreterView;
	}
	
	@Tags({"commandInterpreterControllerFactoryMethod"})
	public static CommandInterpreterControllerInterface commandInterpreterControllerFactoryMethod(){
		if (null == interpreterController){
			interpreterController = new CommandInterpreterController(commandInterpreterViewFactoryMethod());
		}
		return interpreterController;
	}
	
	@Tags({"bridgeSceneControllerFactoryMethod"})
	public static BridgeSceneControllerInterface bridgeSceneControllerFactoryMethod(){
		if (null == mainControl){
			mainControl = new BridgeSceneController(observableBridgeScenePainterFactoryMethod());
		}
		return mainControl;
	}
	
	@Tags({"observableBridgeScenePainterFactoryMethod"})
	public static PaintingViewMaster observableBridgeScenePainterFactoryMethod(){
		if (null == painter){
			painter = new ObservableBridgeScenePainter();
		}
		return painter;
	}
	
	@Tags({"delegatingBridgeSceneViewFactoryMethod"})
	public static DelegatingBridgeSceneViewInterface delegatingBridgeSceneViewFactoryMethod(){
		if (null == view){
			view = new DelegatingBridgeSceneView(bridgeSceneFactoryMethod());
		}
		return view;
	}
	
	@Tags({"scannerFactoryMethod"})
	public static ScannerBeanInterface scannerFactoryMethod(){
		if (null == scannerBean){
			scannerBean = new ScannerBean();
		}
		return scannerBean;
	}
	
	@Tags({"bridgeSceneFactoryMethod"})
	public static BridgeSceneInterface bridgeSceneFactoryMethod(){
		if (null == bridgeScene){
			bridgeScene = new BridgeScene();
		}
		return bridgeScene;
	}
	
	// Side effect: creates a BridgeScene
	@Tags({"avatarTableFactoryMethod"})
	public static Table avatarTableFactoryMethod(){
		if (null == avatarTable){
			avatarTable = new MyTable<AvatarInterface>();
			
			// Create a scene if needed
			bridgeSceneFactoryMethod();	//return value not needed
			
			// Populate table
			avatarTable.put("arthur", bridgeScene.getArthur());
			avatarTable.put("galahad", bridgeScene.getGalahad());
			avatarTable.put("lancelot", bridgeScene.getLancelot());
			avatarTable.put("robin", bridgeScene.getRobin());
			avatarTable.put("guard", bridgeScene.getGuard());
		}
		return avatarTable;
	}
	// Side effect: creates a BridgeScene
	@Tags({"environmentFactoryMethod"})
	public static Table<CommandThread> environmentFactoryMethod(){
		if (null == environment){
			environment = new MyTable<CommandThread>();
			
		
		}
		return environment;
	}
	// Side effect: creates a BridgeScene and ScannerBean
	@Tags({"commandInterpreterFactoryMethod"})
	public static CommandInterpreterInterface commandInterpreterFactoryMethod(){
		if (null == commandInterpreter){
			bridgeSceneFactoryMethod();
			scannerFactoryMethod();
			
			commandInterpreter = new CommandInterpreter(bridgeScene, scannerBean);
		}
		return commandInterpreter;
	}
	
	@Tags({"consoleSceneViewFactoryMethod"})
	public static PropertyChangeListener consoleSceneViewFactoryMethod(){
		if (null == consoleSceneView){
			consoleSceneView = new ConsoleSceneView();
		}
		return consoleSceneView;
	}
	
	@Tags({"broadcastingClearanceManagerFactoryMethod"})
	public static BroadcastingClearanceManager broadcastingClearanceManagerMethod(){
		if (null == clearanceManager){
			clearanceManager = new ABroadcastingClearanceManager();
		}
		return clearanceManager;
	}
}
//END OF FILE
//START OF FILE: src/grail/animations/animatingcommand.java
package grail.animations;

import grail.SingletonsCreator;
import grail.interfaces.AnimatorInterface;
import grail.interfaces.AvatarInterface;
import grail.interfaces.CommandThread;
import util.annotations.Tags;

@Tags({"AnimatingCommand", "CoordinatedAnimationCommand"})
public class AnimatingCommand implements CommandThread{

	private AnimatorInterface animator;
	private AvatarInterface avatar;
	private boolean wait = false;
	
	public AnimatingCommand(AnimatorInterface animator, AvatarInterface avatar){
		this.animator = animator;
		this.avatar = avatar;
	}
	
	/**
	 * Waiting version of animation command.
	 * 
	 * @param animator instance of animator to use
	 * @param avatar avatar to animate
	 * @param wait whether to wait for a notification from ABroadCastingClearanceManager
	 */
	public AnimatingCommand(AnimatorInterface animator, AvatarInterface avatar, boolean wait){
		this.animator = animator;
		this.avatar = avatar;
		this.wait = wait;
	}

	@Override
	public void run() {
		if (wait){
			SingletonsCreator.broadcastingClearanceManagerMethod().waitForProceed();
		}
		animator.animateAvatar(avatar);
	}

}
//END OF FILE
//START OF FILE: src/grail/animations/animator.java
package grail.animations;

import grail.SingletonsCreator;
import grail.interfaces.AnimatorInterface;
import grail.interfaces.AvatarInterface;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.RotatingLineInterface;
import util.annotations.Tags;
import util.misc.ThreadSupport;


@Tags({"Animator", "CoordinatingAnimator"})
public abstract class Animator implements AnimatorInterface {

	private static final int NUM_FRAMES = 15;
	private static final int DEGREES_PER_ROTATE = 6;
	
	private static final int CLAP_DELAY = 300;
	private static final double CLAP_ANGLE = Math.PI / 2;
	
	// Empty constructor
	public Animator() {}

	@Override
	@Tags({"animateAvatar"})
	public synchronized void animateAvatar(AvatarInterface avatar) {
		// Arm up
		for (int i = 0; i < NUM_FRAMES; ++i){
			avatar.getArms().getRightLine().rotateByClockwiseDegrees(-DEGREES_PER_ROTATE);
			pause();
		}
		// Arm down
		for (int i = 0; i < NUM_FRAMES; ++i){
			avatar.getArms().getRightLine().rotateByClockwiseDegrees(DEGREES_PER_ROTATE);
			pause();
		}
	}

	@Override
	public synchronized void clapGuard(BridgeSceneInterface scene) {
		RotatingLineInterface leftArm = scene.getGuard().getArms().getLeftLine();
		RotatingLineInterface rightArm = scene.getGuard().getArms().getRightLine();
		
		double oldLeftAngle = leftArm.getAngle();
		double oldRightAngle = rightArm.getAngle();
		leftArm.setAngle(CLAP_ANGLE);
		rightArm.setAngle(CLAP_ANGLE);
		
		ThreadSupport.sleep(CLAP_DELAY);
		
		leftArm.setAngle(oldLeftAngle);
		rightArm.setAngle(oldRightAngle);
		ThreadSupport.sleep(CLAP_DELAY);
	}
	
	/**
	 * Any lockstep methods move in lockstep with this method.
	 * @param scene
	 */
	@Override
	public synchronized void clapGuardLockstep(BridgeSceneInterface scene) {
		RotatingLineInterface leftArm = scene.getGuard().getArms().getLeftLine();
		RotatingLineInterface rightArm = scene.getGuard().getArms().getRightLine();
		
		double oldLeftAngle = leftArm.getAngle();
		double oldRightAngle = rightArm.getAngle();
		leftArm.setAngle(CLAP_ANGLE);
		rightArm.setAngle(CLAP_ANGLE);
		
		SingletonsCreator.broadcastingClearanceManagerMethod().proceedAll();
		ThreadSupport.sleep(CLAP_DELAY);
		
		leftArm.setAngle(oldLeftAngle);
		rightArm.setAngle(oldRightAngle);
		ThreadSupport.sleep(CLAP_DELAY);
	}
	
	/**
	 * Determines what kind of pauses are used in the animation. These can be sleep calls,
	 * or they can be waits if using lockstep animation.
	 */
	protected abstract void pause();
}
//END OF FILE
//START OF FILE: src/grail/animations/clapcommand.java
package grail.animations;

import grail.interfaces.AnimatorInterface;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandThread;

public class ClapCommand implements CommandThread{

	AnimatorInterface animator;
	BridgeSceneInterface scene;
	
	public ClapCommand(AnimatorInterface animator, BridgeSceneInterface scene){
		this.animator = animator;
		this.scene = scene;
	}
	
	@Override
	public void run() {
		animator.clapGuard(scene);
	}

}
//END OF FILE
//START OF FILE: src/grail/animations/claplockstepcommand.java
package grail.animations;

import grail.interfaces.AnimatorInterface;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandThread;
import util.annotations.Tags;

@Tags({"CoordinatingAnimatingCommand"})
public class ClapLockstepCommand implements CommandThread{

	AnimatorInterface animator;
	BridgeSceneInterface scene;
	
	public ClapLockstepCommand(AnimatorInterface animator, BridgeSceneInterface scene){
		this.animator = animator;
		this.scene = scene;
	}
	
	@Override
	public void run() {
		animator.clapGuardLockstep(scene);
	}

}
//END OF FILE
//START OF FILE: src/grail/animations/sleepbasedanimator.java
package grail.animations;

import grail.interfaces.AnimatorInterface;
import grail.interfaces.AvatarInterface;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.RotatingLineInterface;
import util.annotations.Tags;
import util.misc.ThreadSupport;


@Tags({"Animator"})
public class SleepBasedAnimator extends Animator {

	private static final int ROTATE_DELAY = 60;
	
	// Empty constructor
	public SleepBasedAnimator() {}

	@Override
	protected void pause() {
		ThreadSupport.sleep(ROTATE_DELAY);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/animations/waitbasedanimator.java
package grail.animations;

import grail.SingletonsCreator;
import grail.animations.fromJavaTeaching.BroadcastingClearanceManager;
import grail.interfaces.AnimatorInterface;
import grail.interfaces.AvatarInterface;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.RotatingLineInterface;
import util.annotations.Tags;
import util.misc.ThreadSupport;


@Tags({"CoordinatedAnimator"})
public class WaitBasedAnimator extends Animator {

	private static final int ROTATE_DELAY = 20;
	private BroadcastingClearanceManager clearanceManager;
	
	// Empty constructor
	public WaitBasedAnimator() {
		clearanceManager = SingletonsCreator.broadcastingClearanceManagerMethod();
	}

	@Override
	protected void pause() {
		clearanceManager.waitForProceed();
	}
	
}
//END OF FILE
//START OF FILE: src/grail/animations/fromjavateaching/abroadcastingclearancemanager.java
package grail.animations.fromJavaTeaching;

/**
 * Copied from JavaTeaching, as required from assignment
 */

import util.annotations.ComponentWidth;
import util.annotations.Row;

public class ABroadcastingClearanceManager extends AClearanceManager 
					implements BroadcastingClearanceManager {

	@Row(1)
	@ComponentWidth(100)
	public synchronized void proceedAll() {
		System.out.println( Thread.currentThread() + ": before notifyAll");

		notifyAll(); // not notify, hover over the method and see Java's explanation for it		
		System.out.println( Thread.currentThread() + ": after notifyAll");

	}
}
//END OF FILE
//START OF FILE: src/grail/animations/fromjavateaching/aclearancemanager.java
package grail.animations.fromJavaTeaching;

/**
 * Copied from JavaTeaching, as required by assignment
 */

import java.beans.PropertyChangeListener;

import util.annotations.ComponentWidth;
import util.annotations.Row;
import util.models.AListenableVector;
import util.models.ListenableVector;
import bus.uigen.ObjectEditor;

/*
 Does the println after notify ever not follow the println before notify?
 Does the println after wait ever not follow the println before wait?
 Does the wait ended message ever not follow wait started?
 Does the same thread ever execute both wait and notify?
 */
public class AClearanceManager implements ClearanceManager {
	ListenableVector waitingThreads = new AListenableVector<>();
	PropertyListenerSupport propertyListenerSupport = new APropertyListenerSupport();
	@Row(0)
	@ComponentWidth(100)
	public synchronized void proceed() {
		System.out.println( Thread.currentThread() + ": before notify");
		notify(); // Defined in call Object. Hover over it to see its explanation. Think of a monitor as simply an object.
		System.out.println( Thread.currentThread() + ": after notify");
	}
	public 
//		 Comment out the synchronized keyword. What error do you get? 
		synchronized 
			void waitForProceed() {
			try {
				String aThreadID = Thread.currentThread().toString();
				System.out.println( aThreadID + ": before wait");
				waitingThreads.addElement(aThreadID);
				wait(); // Defined in call Object. Hover over it to see its explanation. Think of a monitor as simply an object.
				System.out.println( aThreadID + ": after wait");
				waitingThreads.removeElement(aThreadID);
			} catch (Exception e) {
				e.printStackTrace();
			}
//		}
	}
	@Row(2)
	public ListenableVector getWaitingThreads() {
		return waitingThreads;

	}
	@Override
	public void addPropertyChangeListener(PropertyChangeListener arg0) {
		propertyListenerSupport.add(arg0);
	}

}
//END OF FILE
//START OF FILE: src/grail/animations/fromjavateaching/apropertylistenersupport.java
package grail.animations.fromJavaTeaching;

/**
 * Copied from JavaTeaching, as required by assignment
 */

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

public class APropertyListenerSupport implements PropertyListenerSupport {
	public final int MAX_SIZE = 50;
	
	// Here we see an array that is capable of storing listeners. Each observer will
	// register a listener with an observable.
	PropertyChangeListener[] contents = new PropertyChangeListener[MAX_SIZE];
	int size = 0;

	public int size() {
		return size;
	}
	
	public PropertyChangeListener get (int index) {
		return contents[index];
	}

	public boolean isFull() {
		return size == MAX_SIZE;

	}

	public void add(PropertyChangeListener l) {
		if (isFull())
			System.out.println("Adding item to a full collection");
		else {
			contents[size] = l;
			size++;
		}
	}
	
	/**
	 * The method notifyAllListeners calls propertyChange():
	 *  (a) a single time on one of the registered observers.
	 *  (b) once for each registered observer.
	 *  (c) never.
	 *  
	 * The method propertyChange is:
	 *  (a) a notification method invoked on a registered observer.
	 *  (b) a registration method invoked on an observer.
	 *  (c) a setter invoked on an observer.
	 */
	public void notifyAllListeners(PropertyChangeEvent event) {
		for (int index = 0; index < size(); index++) {
			/*
			 * Hover over propertyChange to see its documentation
			 * Hover over event to see its instance variables
			 * What kind of object does get(index) return?
			 */
			get(index).propertyChange(event);
		}
	}
	public void remove(PropertyChangeListener element) {
		contents[indexOf(element)] = contents[size - 1];
		size--;
	}

	public void remove(int startIndex) {
		shiftUp(startIndex);
		size--;
	}

	void shiftUp(int startIndex) {
		for (int index = startIndex; index + 1 < size; index++)
			contents[index] = contents[index + 1];
	}

	public int indexOf(PropertyChangeListener element) {
		int index;
		for (index = 0; index < size && !element.equals(contents[index]); index++)
			;
		return index;
	}

	public boolean member(PropertyChangeListener element) {
		return indexOf(element) < size;

	}

	public void clear() {
		size = 0;
	}
}
//END OF FILE
//START OF FILE: src/grail/animations/fromjavateaching/broadcastingclearancemanager.java
package grail.animations.fromJavaTeaching;

public interface BroadcastingClearanceManager extends ClearanceManager {
	public void proceedAll();

}
//END OF FILE
//START OF FILE: src/grail/animations/fromjavateaching/clearancemanager.java
package grail.animations.fromJavaTeaching;

import util.models.PropertyListenerRegisterer;

public interface ClearanceManager extends PropertyListenerRegisterer{
	public void proceed();
	public void waitForProceed();	
	

}
//END OF FILE
//START OF FILE: src/grail/animations/fromjavateaching/propertylistenersupport.java
package grail.animations.fromJavaTeaching;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

public interface PropertyListenerSupport {
	public void add(PropertyChangeListener l);
	public PropertyChangeListener get(int index); 
	public int size();
	public void notifyAllListeners(PropertyChangeEvent event);
	public void remove(PropertyChangeListener element) ;
	public void remove(int startIndex) ;
	public int indexOf(PropertyChangeListener element);
	public boolean member(PropertyChangeListener element);
}
//END OF FILE
//START OF FILE: src/grail/collections/abasehistory.java
package grail.collections;

import grail.interfaces.BaseHistory;
import grail.interfaces.Token;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.VECTOR_PATTERN)
public class ABaseHistory implements BaseHistory {
	
	
	//This collection has a fixed maximum size.
	public static final int MAX_SIZE = 50;
	

	// The underlying array to store the elements
	protected Token[] contents = new Token[MAX_SIZE];
	
	// number of filled elements
	protected int size = 0;	// number of filled elements (protected access)
	
	// Number of filled elements
	@Override
	public int size() {
		return size;
	}
	
	@Override
	public Token elementAt (int index) {
		return contents[index];
	}

	protected boolean isFull() {
		return size == MAX_SIZE;
	}
	
	@Override
	public void addElement(Token element) {
		if (isFull()) {
			System.out.println("Cannot add item to a full history");
		} else {
			contents[size] = element;
			size++;
		}
	} 	
	
}
//END OF FILE
//START OF FILE: src/grail/collections/clearablehistory.java
package grail.collections;

import grail.interfaces.ClearableHistoryInterface;
import grail.interfaces.Token;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@StructurePattern(StructurePatternNames.VECTOR_PATTERN)
@Tags({"ClearableHistory"})
public class ClearableHistory extends ABaseHistory implements ClearableHistoryInterface {

	@Override
	public void clear(){
		size = 0;
		contents = new Token[MAX_SIZE];
	}
}
//END OF FILE
//START OF FILE: src/grail/collections/movecommandundoer.java
package grail.collections;

import java.util.ArrayList;
import java.util.List;

import grail.interfaces.CommandThread;
import grail.interfaces.UndoableCommandThread;
import grail.interfaces.Undoer;
import grail.scanner.commands.MoveCommand;

public class MoveCommandUndoer implements Undoer {

	private List<UndoableCommandThread> moveCommands = new ArrayList<UndoableCommandThread>();
	private int size = 0;
	private int nextCommandIndex = 0;
	
	@Override
	public void execute(UndoableCommandThread c) {
		moveCommands.add(nextCommandIndex, (MoveCommand)c);
		++nextCommandIndex;
		size = nextCommandIndex;
		c.run();
	}
	
	@Override
	public void clear() {
		moveCommands.clear();
		size = 0;
		nextCommandIndex = 0;
	}

	@Override
	public void undo() {
		
		// The command to undo lies right behind nextCommandIndex
		if (nextCommandIndex <= 0){
			return;
		
		}else{
			--nextCommandIndex;
			moveCommands.get(nextCommandIndex).undo();
		}
		
	}

	@Override
	public void redo() {
		if (nextCommandIndex >= size){
			return;
		
		}else{
			CommandThread command = moveCommands.get(nextCommandIndex);
			++nextCommandIndex;
			command.run();
		}
	}

}
//END OF FILE
//START OF FILE: src/grail/collections/mytable.java
package grail.collections;

import java.util.ArrayList;
import java.util.List;

import grail.interfaces.Table;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@StructurePattern(StructurePatternNames.MAP_PATTERN)
@Tags({"Table"})
public class MyTable<KeyType> implements Table<KeyType> {
	
	private List<String> keys = new ArrayList<String>();
	private List<KeyType> values = new ArrayList<KeyType>();
	
	@Override
	public void put (String key, KeyType val){
		if (null == key || null == val){
			return;
		}
		
		int index = keys.indexOf(key);
		
		// If the element was not found, add to both columns
		if (index < 0){
			keys.add(key);
			values.add(val);
		
		// Otherwise update second column
		}else{
			values.set(index, val);
		}
		
	}
	
	@Override
	public KeyType get (String key){
		int index = keys.indexOf(key);
		
		// If not found
		if (index < 0){
			return null;
		
		}else{
			return values.get(index);
		}
	}
	
}//end class
//END OF FILE
//START OF FILE: src/grail/graphics/avatar.java
package grail.graphics;

import java.beans.PropertyChangeListener;

import grail.interfaces.AvatarInterface;
import grail.interfaces.ImageInterface;
import grail.interfaces.RotatingLineInterface;
import grail.interfaces.StringShapeInterface;
import grail.interfaces.VShapeInterface;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;
import util.annotations.Visible;

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@Tags({"Avatar"})
@PropertyNames({"X", "Y","Head", "Legs", "Arms", "Torso", "StringShape"})
@EditablePropertyNames({"X", "Y"})
public class Avatar extends LocatableObject implements AvatarInterface {
	
	// The anchor (avatar location) is the spot between the avatar's feet when the
	// avatar is first created. This is the distance from waist to that point.
	private int floorToWaist;
	
	private static final double TORSO_LENGTH = 80;
	private static final double ARMS_LENGTH = 80;
	private static final double LEGS_LENGTH = 80;
	private static final double TORSO_ANGLE = Math.PI/2;
	
	private ImageInterface head;
	private VShapeInterface legs;
	private VShapeInterface arms;
	private RotatingLineInterface torso;
	private StringShapeInterface stringShape;
	
	public Avatar(ImageInterface head){
		this.head = head;
		
		// Construct other parts
		torso = new RotatingLine(0, 0, TORSO_LENGTH, TORSO_ANGLE);
		arms = new VShape(0, 0, ARMS_LENGTH);
		legs = new VShape(0, 0, LEGS_LENGTH);
		stringShape = new StringShape(0, 0, "");
		
		floorToWaist = legs.getRightLine().getHeight();
		
		// Figure out the postion of the avatar anchor
		int xPos = head.getX() + (head.getWidth()/2);
		int yPos = (int)(head.getY() + head.getHeight()
						+ torso.getRadius() 
						+ floorToWaist);	
		
		// Use setters to build character
		setX(xPos);
		setY(yPos);
	}
	
	public Avatar(int xPos, int yPos, String imageFileName){
		// Construct parts
		head = new Image(0, 0, imageFileName);
		torso = new RotatingLine(0, 0, TORSO_LENGTH, TORSO_ANGLE);
		arms = new VShape(0, 0, ARMS_LENGTH);
		legs = new VShape(0, 0, LEGS_LENGTH);
		stringShape = new StringShape(0, 0, "");
		
		// Use setters to build character
		setX(xPos);
		setY(yPos);
	}
	
	@Visible(false)
	@Override
	public void setX(int newX) {
		
		super.setX(newX);
		
		// Place the character:
		// Since character is upright, everything is already
		// centered except the head and utterance
		legs.setX(newX);
		torso.setX(newX);
		arms.setX(newX);
		
		head.setX(newX-(head.getWidth())/2);
		stringShape.setX(head.getX() + head.getWidth());
	}
	
	@Visible(false)
	@Override
	public void setY(int newY) {
		
		super.setY(newY);
		
		// Place the character:
		legs.setY(newY-floorToWaist);
		
		int torsoTop = legs.getY()-torso.getHeight();
		torso.setY(torsoTop);
		arms.setY(torsoTop);
		
		// Head anchor is at its top, so adjust
		head.setY(torsoTop - head.getHeight());
		
		stringShape.setY(head.getY());
	}

	@Override
	public StringShapeInterface getStringShape() {
		return stringShape;
	}

	@Override
	public ImageInterface getHead() {
		return head;
	}

	@Override
	public VShapeInterface getArms() {
		return arms;
	}

	@Override
	public VShapeInterface getLegs() {
		return legs;
	}

	@Override
	public RotatingLineInterface getTorso() {
		return torso;
	}

	@Tags({"move"})
	@Override
	public void move(int changeInX, int changeInY) {
		setX(getX()+changeInX);
		setY(getY()+changeInY);
	}

	@Tags({"scale"})
	@Override
	public void scale(double scalar) {
		
		// Ceiling necessary because otherwise small changes are not visible
		head.setHeight((int)Math.ceil(head.getHeight() * scalar));
		head.setWidth((int)Math.ceil(head.getWidth()*scalar));
		
		legs.setLinesLength(legs.getLinesLength() * scalar);
		arms.setLinesLength(arms.getLinesLength() * scalar);
		torso.setRadius(torso.getRadius() * scalar);
		
		// Use setters to reconstruct body
		setX(getX());
		setY(getY());
	}
	
	@Override
	public void addPropertyChangeListenerToAtomics(PropertyChangeListener listener){
		getArms().addPropertyChangeListenerToAtomics(listener);
		getLegs().addPropertyChangeListenerToAtomics(listener);
		getHead().addPropertyChangeListener(listener);
		getStringShape().addPropertyChangeListener(listener);
		getTorso().addPropertyChangeListener(listener);
	}
}
//END OF FILE
//START OF FILE: src/grail/graphics/boundedshape.java
package grail.graphics;

import java.beans.PropertyChangeEvent;

import grail.interfaces.BoundedShapeInterface;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"X", "Y", "Width", "Height"})
@EditablePropertyNames({"X", "Y", "Width", "Height"})
@Tags({"BoundedShape"})
public abstract class BoundedShape extends ObservableLocatableObject implements BoundedShapeInterface {

	private int width;
	private int height;
	
	public BoundedShape (int xPos, int yPos, int width, int height){
		super (xPos,yPos);
		this.width = width;
		this.height = height;
	}
	
	// empty constructor
	public BoundedShape(){}
	
	@Override
	public void setWidth(int newWidth) {
		int oldWidth = width;
		width = newWidth;
//		System.out.println ("Notifying width " + Thread.currentThread());

		notifyAllListeners(new PropertyChangeEvent(this, "Width", oldWidth, newWidth));
	}

	@Override
	public int getWidth() {
		return width;
	}

	@Override
	public void setHeight(int newHeight) {
		int oldHeight = height;
		height = newHeight;
		notifyAllListeners(new PropertyChangeEvent(this, "Height", oldHeight, newHeight));
	}

	@Override
	public int getHeight() {
		return height;
	}

	@Override
	@Tags({"move"})
	public void move(int moveX, int moveY) {
		setX(getX() + moveX);
		setY(getY() + moveY);
	}

}
//END OF FILE
//START OF FILE: src/grail/graphics/bridgescene.java
package grail.graphics;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.List;

import grail.interfaces.AvatarInterface;
import grail.interfaces.BoundedShapeInterface;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.GorgeWithBridgeInterface;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@Tags({"BridgeScene"})
@PropertyNames({"Guard", "Arthur", "Lancelot","Robin", "Galahad",
	"Gorge", "GuardArea", "KnightArea", "Occupied", "KnightTurn"})
public class BridgeScene implements BridgeSceneInterface {

	private static final String EMPTY_STRING = "";
	
	private static final int ARTHUR_LOCATION_X = 100;
	private static final int ARTHUR_LOCATION_Y = 300;
	private static final int LANCELOT_LOCATION_X = 200;
	private static final int LANCELOT_LOCATION_Y = 300;
	private static final int ROBIN_LOCATION_X = 300;
	private static final int ROBIN_LOCATION_Y = 300;
	private static final int GALAHAD_LOCATION_X = 400;
	private static final int GALAHAD_LOCATION_Y = 300;
	private static final int GUARD_LOCATION_X = 750;
	private static final int GUARD_LOCATION_Y = 300;
	
	private static final int GORGE_LEFT_X = 850;
	private static final int GORGE_RIGHT_X = 1050;
	private static final int BRIDGE_WIDTH = 50;
	private static final int BRIDGE_Y = 275;
	
	private static final int KNIGHT_AREA_X = 500;
	private static final int KNIGHT_AREA_Y = 250;
	private static final int GUARD_AREA_X = 700;
	private static final int GUARD_AREA_Y = 250;
	
	private static final int AREA_DIAMETERS = 100;
	
	private static final int PASS_DESTINATION_X = GORGE_RIGHT_X + 100;
	private static final int FAIL_DESTINATION_X = (GORGE_LEFT_X + GORGE_RIGHT_X)/2;
	private static final int FAIL_DESTINATION_Y = BRIDGE_Y + 300;
	
	private static final String ARTHUR_FILE_LOCATION = "images/arthur.jpg";
	private static final String LANCELOT_FILE_LOCATION = "images/lancelot.jpg";
	private static final String ROBIN_FILE_LOCATION = "images/robin.jpg";
	private static final String GALAHAD_FILE_LOCATION = "images/galahad.jpg";
	private static final String GUARD_FILE_LOCATION = "images/guard.jpg";
	
	private static final String PRECONDITION_PROPERTY = "this";
	private static final String APPROACH_METHOD_TAG = "approach";
	private static final String SAY_METHOD_TAG = "say";
	private static final String PASSED_METHOD_TAG = "passed";
	private static final String FAILED_METHOD_TAG = "failed";
	
	private AvatarInterface arthur;
	private AvatarInterface lancelot;
	private AvatarInterface robin;
	private AvatarInterface galahad;
	private AvatarInterface guard;
	
	private AvatarInterface occupyingKnight;
	
	private GorgeWithBridgeInterface gorge;
	private BoundedShapeInterface knightArea;
	private BoundedShapeInterface guardArea;
	
	private boolean occupied;
	private boolean knightTurn;
	
	private List<PropertyChangeListener> listeners = new ArrayList<PropertyChangeListener>();
	
	public BridgeScene(){
		arthur = new Avatar(ARTHUR_LOCATION_X, ARTHUR_LOCATION_Y, ARTHUR_FILE_LOCATION);
		lancelot = new Avatar(LANCELOT_LOCATION_X, LANCELOT_LOCATION_Y, LANCELOT_FILE_LOCATION);
		robin = new Avatar(ROBIN_LOCATION_X, ROBIN_LOCATION_Y, ROBIN_FILE_LOCATION);
		galahad = new Avatar(GALAHAD_LOCATION_X, GALAHAD_LOCATION_Y, GALAHAD_FILE_LOCATION);
		guard = new Avatar(GUARD_LOCATION_X,GUARD_LOCATION_Y, GUARD_FILE_LOCATION);
		
		gorge = new GorgeWithBridge(GORGE_LEFT_X, GORGE_RIGHT_X, BRIDGE_Y, BRIDGE_WIDTH);
		knightArea = new Oval(KNIGHT_AREA_X, KNIGHT_AREA_Y, AREA_DIAMETERS, AREA_DIAMETERS);
		guardArea = new Oval(GUARD_AREA_X, GUARD_AREA_Y, AREA_DIAMETERS, AREA_DIAMETERS);
		
		occupied = false;
		knightTurn = false;
	}
	
	@Override
	@Tags({"approach"})
	public void approach(AvatarInterface knight){
		assert preApproach();	//cannot be occupied
		
		// Place knight in middle of proper area
		knight.setX(knightArea.getX() + knightArea.getWidth()/2);
		knight.setY(knightArea.getY() + knightArea.getHeight()/2);
		occupied = true;
		knightTurn = false;
		occupyingKnight = knight;
		
		// Can now say, pass, or fail, but not approach
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, APPROACH_METHOD_TAG, false));
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, SAY_METHOD_TAG, true));
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, PASSED_METHOD_TAG, true));
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, FAILED_METHOD_TAG, true));
	}
	
	@Override
	public boolean preApproach(){
		return !getOccupied();
	}
	
	@Override
	@Tags({"say"})
	public void say(String string){
		assert getOccupied();
		
		if (getKnightTurn()){
			occupyingKnight.getStringShape().setText(string);
			getGuard().getStringShape().setText(EMPTY_STRING);
			knightTurn = false;
		}else{
			getGuard().getStringShape().setText(string);
			occupyingKnight.getStringShape().setText(EMPTY_STRING);
			knightTurn = true;
		}
		
		// Pass alternates between being allowed and not allowed
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, PASSED_METHOD_TAG, prePassed()));
	}
	
	@Override
	public boolean preSay(){
		return getOccupied();
	}
	
	@Override
	@Tags({"passed"})
	public void passed(){
		assert prePassed();	// has to be occupied, has to be guard's turn
		
		occupyingKnight.setX(PASS_DESTINATION_X);
		
		// Reset challenge area
		occupyingKnight.getStringShape().setText(EMPTY_STRING);
		getGuard().getStringShape().setText(EMPTY_STRING);
		occupied = false;
		occupyingKnight = null;

		// Can now approach, but not say, pass, or fail
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, APPROACH_METHOD_TAG, true));
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, SAY_METHOD_TAG, false));
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, PASSED_METHOD_TAG, false));
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, FAILED_METHOD_TAG, false));
	}
	
	@Override
	public boolean prePassed(){
		return (getOccupied() && !getKnightTurn());
	}
	
	@Override
	@Tags({"failed"})
	public void failed(){
		assert preFailed();	//has to be occupied
		
		// if knight's turn, then guard falls
		if (getKnightTurn()){
			getGuard().getStringShape().setText(EMPTY_STRING);
			getGuard().setX(FAIL_DESTINATION_X);
			getGuard().setY(FAIL_DESTINATION_Y);
		}else{
			occupyingKnight.setX(FAIL_DESTINATION_X);
			occupyingKnight.setY(FAIL_DESTINATION_Y);
			occupyingKnight.getStringShape().setText(EMPTY_STRING);
			occupied = false;
			occupyingKnight = null;
		}
		
		// Can now approach, but not say, pass, or fail
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, APPROACH_METHOD_TAG, true));
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, SAY_METHOD_TAG, false));
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, PASSED_METHOD_TAG, false));
		notifyAllListeners(new PropertyChangeEvent(this, PRECONDITION_PROPERTY, FAILED_METHOD_TAG, false));
	}
	
	@Override
	public boolean preFailed(){
		return getOccupied();
	}
	
	@Override
	@Tags({"scroll"})
	public void scroll(int scrollX, int scrollY) {
		arthur.move(-scrollX, -scrollY);
		lancelot.move(-scrollX, -scrollY);
		robin.move(-scrollX, -scrollY);
		galahad.move(-scrollX, -scrollY);
		guard.move(-scrollX, -scrollY);
		
		gorge.move(-scrollX, -scrollY);
		knightArea.move(-scrollX, -scrollY);
		guardArea.move(-scrollX, -scrollY);
	}
	
	@Override
	public boolean getOccupied(){
		return occupied;
	}
	
	@Override
	public boolean getKnightTurn(){
		return knightTurn;
	}
	
	@Override
	public GorgeWithBridgeInterface getGorge(){
		return gorge;
	}
	
	@Override
	public BoundedShapeInterface getKnightArea(){
		return knightArea;
	}
	
	@Override
	public BoundedShapeInterface getGuardArea(){
		return guardArea;
	}
	
	@Override
	public AvatarInterface getArthur() {
		return arthur;
	}

	@Override
	public AvatarInterface getLancelot() {
		return lancelot;
	}

	@Override
	public AvatarInterface getRobin() {
		return robin;
	}

	@Override
	public AvatarInterface getGalahad() {
		return galahad;
	}

	@Override
	public AvatarInterface getGuard() {
		return guard;
	}

	@Override
	public void addPropertyChangeListener(PropertyChangeListener listener) {
		listeners.add(listener);
	}
	
	protected void notifyAllListeners(PropertyChangeEvent e){
		for (PropertyChangeListener listener : listeners){
			listener.propertyChange(e);
		}
	}
}
//END OF FILE
//START OF FILE: src/grail/graphics/gorgewithbridge.java
package grail.graphics;

import grail.interfaces.GorgeWithBridgeInterface;
import grail.interfaces.BoundedShapeInterface;
import grail.interfaces.RotatingLineInterface;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Visible;

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"LeftSide", "RightSide", "Bridge", "LeftX", "RightX", "UpperY", "BridgeWidth", "GorgeLength"})
@EditablePropertyNames({"LeftX", "RightX", "UpperY", "BridgeWidth", "GorgeLength"})
public class GorgeWithBridge implements GorgeWithBridgeInterface {
	
	private static final int DEFAULT_UPPER_Y = -1000;
	private static final int DEFAULT_LENGTH = 4000;
	private static final double ANGLE_DOWNWARD = Math.PI/2;
	
	private RotatingLineInterface leftSide;
	private RotatingLineInterface rightSide;
	private BoundedShapeInterface bridge;
	
	// Constructors
	public GorgeWithBridge(int leftX, int rightX, int bridgeY, int bridgeWidth){
		leftSide = new RotatingLine(leftX, DEFAULT_UPPER_Y, DEFAULT_LENGTH, ANGLE_DOWNWARD);
		rightSide = new RotatingLine(rightX, DEFAULT_UPPER_Y, DEFAULT_LENGTH, ANGLE_DOWNWARD);
		
		// bridgeWidth refers to the width of the bridge, which is the height of the rectangle
		bridge = new Rectangle(leftX, bridgeY, rightX-leftX, bridgeWidth);
	}
	
	public GorgeWithBridge(int leftX, int rightX, int y, int gorgeLength, int bridgeY, int bridgeWidth){
		leftSide = new RotatingLine(leftX, y, gorgeLength, ANGLE_DOWNWARD);
		rightSide = new RotatingLine(rightX, y, gorgeLength, ANGLE_DOWNWARD);
		
		bridge = new Rectangle(leftX, bridgeY, rightX-leftX, bridgeWidth);
	}
	
	@Override
	public RotatingLineInterface getLeftSide(){
		return leftSide;
	}
	
	@Override
	public RotatingLineInterface getRightSide(){
		return rightSide;
	}
	
	@Override
	public BoundedShapeInterface getBridge(){
		return bridge;
	}
	
	@Override
	@Visible(false)
	public int getUpperY(){
		return leftSide.getY();
	}
	@Override
	@Visible(false)
	public void setUpperY(int y){
		leftSide.setY(y);
		rightSide.setY(y);
	}
	
	@Override
	@Visible(false)
	public int getLeftX(){
		return leftSide.getX();
	}
	@Override
	@Visible(false)
	public void setLeftX(int x){
		leftSide.setX(x);
		bridge.setX(x);
		bridge.setWidth(rightSide.getX() - x);
	}
	
	@Override
	@Visible(false)
	public int getRightX(){
		return rightSide.getX();
	}
	@Override
	@Visible(false)
	public void setRightX(int x){
		rightSide.setX(x);
		bridge.setWidth(x- leftSide.getX());
	}
	
	@Override
	@Visible(false)
	public int getBridgeWidth(){
		return bridge.getHeight();
	}
	@Override
	@Visible(false)
	public void setBridgeWidth(int width){
		bridge.setHeight(width);
	}
	
	@Override
	@Visible(false)
	public int getGorgeLength(){
		return (int)leftSide.getRadius();
	}
	@Override
	@Visible(false)
	public void setGorgeLength(int length){
		leftSide.setRadius(length);
		rightSide.setRadius(length);
	}

	@Override
	public void move(int moveX, int moveY) {
		leftSide.setX(leftSide.getX() + moveX);
		leftSide.setY(leftSide.getY() + moveY);
		rightSide.setX(rightSide.getX() + moveX);
		rightSide.setY(rightSide.getY() + moveY);
		bridge.move(moveX, moveY);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/graphics/image.java
package grail.graphics;

import java.beans.PropertyChangeEvent;

import javax.swing.Icon;
import javax.swing.ImageIcon;

import grail.interfaces.ImageInterface;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.IMAGE_PATTERN)
@PropertyNames({"X", "Y", "Width", "Height", "ImageFileName"})
@EditablePropertyNames({"X", "Y", "Width", "Height", "ImageFileName"})
public class Image extends Rectangle implements ImageInterface {

	private String imageFileName;
	
	public Image(int xPos, int yPos, int width, int height, String imageFileName){
		super(xPos, yPos, width, height);
		this.imageFileName = imageFileName;
	}
	
	public Image(int xPos, int yPos, String imageFileName){
		super(xPos, yPos, 0, 0);		//temporary height and width
		
		this.imageFileName = imageFileName;
		
		// Use image height and width
		Icon icon = new ImageIcon(imageFileName);
		setHeight(icon.getIconHeight());
		setWidth(icon.getIconWidth());
	}
	
	@Override
	public void setImageFileName(String newFileName) {
		String oldFileName = imageFileName;
		imageFileName = newFileName;
		notifyAllListeners(new PropertyChangeEvent(this, "ImageFileName", oldFileName, newFileName));
	}

	@Override
	public String getImageFileName() {
		return imageFileName;
	}

}
//END OF FILE
//START OF FILE: src/grail/graphics/locatableobject.java
package grail.graphics;

import grail.interfaces.Locatable;

public abstract class LocatableObject implements Locatable{


	private int x;
	private int y;
	
	public LocatableObject(int xPos, int yPos){
		x = xPos;
		y = yPos;
	}
	
	// Empty constructor
	public LocatableObject(){}
	
	@Override
	public int getX() {
		return x;
	}
	
	@Override
	public void setX(int newX) {
		x = newX;
	}

	@Override
	public int getY() {
		return y;
	}
	
	@Override
	public void setY(int newY) {
		y = newY;
	}

}
//END OF FILE
//START OF FILE: src/grail/graphics/observablelocatableobject.java
package grail.graphics;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.List;

import grail.interfaces.ObservableLocatable;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"X", "Y"})
@EditablePropertyNames({"X", "Y"})
@Tags({"Locatable"})
public abstract class ObservableLocatableObject extends LocatableObject implements ObservableLocatable{

	private List<PropertyChangeListener> listeners = new ArrayList<PropertyChangeListener>();
	
	public ObservableLocatableObject(int xPos, int yPos){
		super(xPos,yPos);
	}
	
	// Empty constructor
	public ObservableLocatableObject(){}
	
	@Override
	public void setX(int newX) {
		int oldX = getX();
		super.setX(newX);
//		System.out.println ("Notifying x " + Thread.currentThread());
		notifyAllListeners(new PropertyChangeEvent(this, "X", oldX, newX));
	}
	
	@Override
	public void setY(int newY) {
		int oldY = getY();
		super.setY(newY);
		notifyAllListeners(new PropertyChangeEvent(this, "Y", oldY, newY));
	}

	@Override
	public void addPropertyChangeListener(PropertyChangeListener listener) {
		listeners.add(listener);
	}
	
	protected void notifyAllListeners(PropertyChangeEvent e){
		for (PropertyChangeListener listener : listeners){
			listener.propertyChange(e);
		}
	}

}
//END OF FILE
//START OF FILE: src/grail/graphics/oval.java
package grail.graphics;

import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.OVAL_PATTERN)
@PropertyNames({"X", "Y", "Width", "Height"})
@EditablePropertyNames({"X", "Y", "Width", "Height"})
public class Oval extends BoundedShape{
	
	public Oval (int xPos, int yPos, int width, int height){
		super(xPos, yPos, width, height);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/graphics/rectangle.java
package grail.graphics;

import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.RECTANGLE_PATTERN)
@PropertyNames({"X", "Y", "Width", "Height"})
@EditablePropertyNames({"X", "Y", "Width", "Height"})
public class Rectangle extends BoundedShape {

	
	public Rectangle (int xPos, int yPos, int width, int height){
		super(xPos, yPos, width, height);
	}
	

}
//END OF FILE
//START OF FILE: src/grail/graphics/rotatingline.java
package grail.graphics;

import java.beans.PropertyChangeEvent;

import grail.interfaces.RotatingLineInterface;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"RotatingLine"})
@StructurePattern(StructurePatternNames.LINE_PATTERN)
@PropertyNames({"Height", "Width", "X", "Y","Angle", "Radius"})
@EditablePropertyNames({"X", "Y","Angle", "Radius"})
public class RotatingLine extends BoundedShape implements RotatingLineInterface{
	
	private static final double DEGREE_IN_RADIANS = Math.PI / 180;
	private static final double DEFAULT_RADIUS = 100;
	
	private double radius = DEFAULT_RADIUS;
	private double angle = 0;
	
	public RotatingLine(){
		setX(0);
		setY(0);
	}
	
	public RotatingLine(int xPos, int yPos, double r, double theta){
		setX(xPos);
		setY(yPos);
		radius = r;
		angle = theta;
	}
	
	@Override
	public int getHeight() {
		return (int)(radius*Math.sin(angle));
	}

	@Override
	public int getWidth() {
		return (int)(radius*Math.cos(angle));
	}

	@Override
	public void setRadius(double r) {
		int oldWidth = getWidth();
		int oldHeight = getHeight();
		
		radius = r;
//		System.out.println ("Notifying line:" + Thread.currentThread()); 

		notifyAllListeners(new PropertyChangeEvent(this, "Width", oldWidth, getWidth()));
		notifyAllListeners(new PropertyChangeEvent(this, "Height", oldHeight, getHeight()));
	}

	@Override
	public double getRadius() {
		return radius;
	}

	/**
	 * Angle is in radians, clockwise from right horizontal
	 */
	@Override
	public void setAngle(double theta) {
		int oldWidth = getWidth();
		int oldHeight = getHeight();
		
		angle = theta;
//		System.out.println ("notifying angle " + Thread.currentThread());
		notifyAllListeners(new PropertyChangeEvent(this, "Width", oldWidth, getWidth()));
		notifyAllListeners(new PropertyChangeEvent(this, "Height", oldHeight, getHeight()));
	}
	
	/**
	 * Angle is in radians, clockwise from right horizontal
	 */
	@Override
	public double getAngle() {
		return angle;
	}

	@Override
	@Tags({"rotate"})
	public void rotateByClockwiseDegrees(int degrees) {
		setAngle(getAngle() + (degrees * DEGREE_IN_RADIANS));
	}

}
//END OF FILE
//START OF FILE: src/grail/graphics/stringshape.java
package grail.graphics;

import java.beans.PropertyChangeEvent;

import grail.interfaces.StringShapeInterface;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.STRING_PATTERN)
@PropertyNames({"X", "Y", "Text"})
@EditablePropertyNames({"X", "Y", "Text"})
public class StringShape extends ObservableLocatableObject implements StringShapeInterface {

	private String text;
	
	public StringShape(int xPos, int yPos, String text){
		super(xPos, yPos);
		this.text = text;
	}
	
	@Override
	public void setText(String newString) {
		String oldString = text;
		text = newString;
		notifyAllListeners(new PropertyChangeEvent(this, "Text", oldString, newString));
	}

	@Override
	public String getText() {
		return text;
	}

}
//END OF FILE
//START OF FILE: src/grail/graphics/vshape.java
package grail.graphics;

import java.beans.PropertyChangeListener;

import grail.interfaces.RotatingLineInterface;
import grail.interfaces.VShapeInterface;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;
import util.annotations.Visible;

@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@Tags({"Angle"})
@PropertyNames({"X", "Y","LeftLine", "RightLine", "LinesLength"})
@EditablePropertyNames({"X", "Y", "LinesLength"})
public class VShape extends LocatableObject implements VShapeInterface {

	private RotatingLineInterface leftLine;
	private RotatingLineInterface rightLine;
	
	private static final double DEFAULT_LINE_LENGTH = 80;
	private static final double RIGHT_LINE_START_ANGLE = Math.PI/3;
	private static final double LEFT_LINE_START_ANGLE = 2*Math.PI/3;
	
	/**
	 * The only required constructor.
	 */
	public VShape(){
		rightLine = new RotatingLine(0, 0, DEFAULT_LINE_LENGTH, RIGHT_LINE_START_ANGLE);
		leftLine = new RotatingLine(0, 0, DEFAULT_LINE_LENGTH, LEFT_LINE_START_ANGLE);
		
		//Make the entire shape fit in the leftmost corner 
		setX(0 + Math.abs(leftLine.getWidth()));
		setY(0);
	}
	
	public VShape(int xPos, int yPos, double lineLengths){
		super(xPos, yPos);
		rightLine = new RotatingLine(xPos,yPos, lineLengths, RIGHT_LINE_START_ANGLE);
		leftLine = new RotatingLine(xPos,yPos, lineLengths, LEFT_LINE_START_ANGLE);
	}
	
	@Visible(false)
	@Override
	public void setX(int newX) {
		super.setX(newX);
		leftLine.setX(newX);
		rightLine.setX(newX);
	}

	@Visible(false)
	@Override
	public void setY(int newY) {
		super.setY(newY);
		leftLine.setY(newY);
		rightLine.setY(newY);
	}

	@Override
	public RotatingLineInterface getLeftLine() {
		return leftLine;
	}

	@Override
	public RotatingLineInterface getRightLine() {
		return rightLine;
	}

	@Override
	public void move(int changeInX, int changeInY) {
		setX(getX() + changeInX);
		setY(getY() + changeInY);
	}

	/**
	 * If line lengths differ, gives length of left line.
	 */
	@Override
	@Visible(false)
	public double getLinesLength() {
		return leftLine.getRadius();
	}

	@Override
	@Visible(false)
	public void setLinesLength(double newLength) {
		leftLine.setRadius(newLength);
		rightLine.setRadius(newLength);
	}
	
	@Override
	public void addPropertyChangeListenerToAtomics(PropertyChangeListener listener){
		getLeftLine().addPropertyChangeListener(listener);
		getRightLine().addPropertyChangeListener(listener);
	}
}
//END OF FILE
//START OF FILE: src/grail/interfaces/animatorinterface.java
package grail.interfaces;

import util.annotations.Tags;

@Tags({"Animator"})
public interface AnimatorInterface {
	
	@Tags({"animateAvatar"})
	public void animateAvatar(AvatarInterface avatar);
	
	public void clapGuard(BridgeSceneInterface scene);
	public void clapGuardLockstep(BridgeSceneInterface scene);
}
//END OF FILE
//START OF FILE: src/grail/interfaces/avatarinterface.java
package grail.interfaces;

import java.beans.PropertyChangeListener;

import util.annotations.Tags;

@Tags({"Avatar", "move"})
public interface AvatarInterface extends Locatable{
	
	public StringShapeInterface getStringShape();
	
	public ImageInterface getHead();
	
	public VShapeInterface getArms();
	
	public VShapeInterface getLegs();
	
	public RotatingLineInterface getTorso();
	
	public void move(int changeInX, int changeInY);
	public void scale(double scalar);

	void addPropertyChangeListenerToAtomics(PropertyChangeListener listener);
}
//END OF FILE
//START OF FILE: src/grail/interfaces/basehistory.java
package grail.interfaces;

public interface BaseHistory {
	public void addElement(Token element);
	public Token elementAt (int index); 
	public int size();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/boundedshapeinterface.java
package grail.interfaces;

import util.annotations.Tags;

@Tags({"BoundedShape"})
public interface BoundedShapeInterface extends ObservableLocatable{

	public void setWidth(int newWidth);
	public int getWidth();
	
	public void setHeight(int newHeight);
	public int getHeight();
	
	@Tags({"move"})
	public void move(int moveX, int moveY);
}
//END OF FILE
//START OF FILE: src/grail/interfaces/bridgesceneinterface.java
package grail.interfaces;

import util.annotations.Tags;
import util.models.PropertyListenerRegisterer;

@Tags({"BridgeScene"})
public interface BridgeSceneInterface extends PropertyListenerRegisterer{
	public AvatarInterface getArthur();
	public AvatarInterface getLancelot();
	public AvatarInterface getRobin();
	public AvatarInterface getGalahad();
	public AvatarInterface getGuard();
	
	public GorgeWithBridgeInterface getGorge();
	public BoundedShapeInterface getKnightArea();
	public BoundedShapeInterface getGuardArea();
	
	@Tags({"approach"})
	public void approach(AvatarInterface knight);
	
	@Tags({"say"})
	public void say(String string);
	
	@Tags({"passed"})
	public void passed();
	
	@Tags({"failed"})
	public void failed();
	public boolean getOccupied();
	public boolean getKnightTurn();
	
	@Tags({"scroll"})
	public void scroll(int scrollAmount, int i);
	
	public boolean preFailed();
	public boolean prePassed();
	public boolean preSay();
	public boolean preApproach();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/clearablehistoryinterface.java
package grail.interfaces;

import util.annotations.Tags;

@Tags({"ClearableHistory"})
public interface ClearableHistoryInterface extends BaseHistory {
	public void clear();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/commandinterpreterinterface.java
package grail.interfaces;

import java.beans.PropertyChangeListener;

import util.annotations.Tags;

@Tags({"CommandInterpreter", "SignedMoveCommandInterpreter", "ErrorResilientCommandInterpreter","ObservableCommandInterpreter"})
public interface CommandInterpreterInterface {

	public String getCommand();
	public void setCommand(String command);

	public String getErrors();
	public void addPropertyChangeListener(PropertyChangeListener listener);
	
	@Tags({"asynchronousArthur"})
	public void asynchronousArthur();
	
	@Tags({"asynchronousGalahad"})
	public void asynchronousGalahad();
	
	@Tags({"asynchronousLancelot"})
	public void asynchronousLancelot();
	
	@Tags({"asynchronousRobin"})
	public void asynchronousRobin();
	
	@Tags({"asynchronousGuard"})
	public void asynchronousGuard();
	
	@Tags({"waitingArthur"})
	public void waitingArthur();
	
	@Tags({"waitingGalahad"})
	public void waitingGalahad();
	
	@Tags({"waitingLancelot"})
	public void waitingLancelot();
	
	@Tags({"waitingRobin"})
	public void waitingRobin();
	
	@Tags({"startAnimation"})
	public void startAnimation();

	@Tags({"lockstepArthur"})
	public void lockstepArthur();
	
	@Tags({"lockstepGalahad"})
	public void lockstepGalahad();
	
	@Tags({"lockstepLancelot"})
	public void lockstepLancelot();
	
	@Tags({"lockstepRobin"})
	public void lockstepRobin();
	
	@Tags({"lockstepGuard"})
	public void lockstepGuard();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/commandthread.java
package grail.interfaces;

public interface CommandThread extends Runnable{

}
//END OF FILE
//START OF FILE: src/grail/interfaces/compositecommandthread.java
package grail.interfaces;

public interface CompositeCommandThread extends CommandThread{
	public void add(Runnable r);
}
//END OF FILE
//START OF FILE: src/grail/interfaces/gorgewithbridgeinterface.java
package grail.interfaces;


public interface GorgeWithBridgeInterface {

	public RotatingLineInterface getLeftSide();
	public RotatingLineInterface getRightSide();
	public BoundedShapeInterface getBridge();

	public int getUpperY();
	public void setUpperY(int y);

	public int getLeftX();
	public void setLeftX(int x);

	public int getRightX();
	public void setRightX(int x);

	public int getBridgeWidth();
	public void setBridgeWidth(int width);

	public int getGorgeLength();
	public void setGorgeLength(int length);
	
	public void move(int moveX, int moveY);
}
//END OF FILE
//START OF FILE: src/grail/interfaces/imageinterface.java
package grail.interfaces;

import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.IMAGE_PATTERN)
public interface ImageInterface extends BoundedShapeInterface{
	public void setImageFileName(String imageFileName);
	public String getImageFileName();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/locatable.java
package grail.interfaces;

import util.annotations.Tags;

@Tags({"Locatable"})
public interface Locatable {
	
	public void setX(int newX);
	public int getX();

	public void setY(int newY);
	public int getY();
	
}
//END OF FILE
//START OF FILE: src/grail/interfaces/number.java
package grail.interfaces;

import util.annotations.Tags;

@Tags({"Number"})
public interface Number extends Token {
	public int getValue();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/observablelocatable.java
package grail.interfaces;

import util.models.PropertyListenerRegisterer;

public interface ObservableLocatable extends Locatable, PropertyListenerRegisterer{

}
//END OF FILE
//START OF FILE: src/grail/interfaces/parserinterface.java
package grail.interfaces;

import util.annotations.Tags;

@Tags({"Parser"})
public interface ParserInterface {

	public String getCommandText();
	public void setCommandText(String string);
	public CommandThread getCommandObject();
	public String getErrors();

}
//END OF FILE
//START OF FILE: src/grail/interfaces/parsingexceptioninterface.java
package grail.interfaces;

import util.annotations.Tags;

/**
 * Only exists to fulfill requirements regarding public methods being
 * in interfaces
 *
 */
@Tags({"ParsingException"})
public interface ParsingExceptionInterface {

	public String getExpected();
	public String getEncountered();

}
//END OF FILE
//START OF FILE: src/grail/interfaces/rotatinglineinterface.java
package grail.interfaces;

import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@StructurePattern(StructurePatternNames.LINE_PATTERN)
@Tags({"RotatingLine"})
public interface RotatingLineInterface extends BoundedShapeInterface{

	public void setRadius(double r);
	public double getRadius();
	
	public void setAngle(double theta);
	public double getAngle();
	
	@Tags({"rotate"})
	public void rotateByClockwiseDegrees(int degrees);
}
//END OF FILE
//START OF FILE: src/grail/interfaces/scannerbeaninterface.java
package grail.interfaces;

import grail.scanner.ScanningException;
import util.annotations.Tags;

@Tags({"ScannerBean"})
public interface ScannerBeanInterface {
	public String getScannedString();
	public void setScannedString(String s) throws ScanningException;
	public Token[] getTokens();
	public String[] getErrors();
	public ClearableHistoryInterface getTokenList();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/scanningexceptioninterface.java
package grail.interfaces;

/**
 * Only exists to fulfill requirements regarding public methods being
 * in interfaces
 *
 */
public interface ScanningExceptionInterface {

	public String[] getErrors();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/stringshapeinterface.java
package grail.interfaces;

import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;

@StructurePattern(StructurePatternNames.STRING_PATTERN)
public interface StringShapeInterface extends ObservableLocatable{
	
	public void setText(String newString);
	public String getText();
	
}
//END OF FILE
//START OF FILE: src/grail/interfaces/table.java
package grail.interfaces;

import util.annotations.Tags;

@Tags({"Table"})
public interface Table<KeyType> {

	public void put(String key, KeyType val);
	public KeyType get(String key);

}
//END OF FILE
//START OF FILE: src/grail/interfaces/token.java
package grail.interfaces;

import util.annotations.Tags;

@Tags({"Token", "Number", "Word", "Quote", "Plus", "Minus", "Start", "End"})
public interface Token {
	
	public void setInput(String newString);
	public String getInput();

}
//END OF FILE
//START OF FILE: src/grail/interfaces/undoablecommandthread.java
package grail.interfaces;

public interface UndoableCommandThread extends CommandThread {
	public void undo();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/undoer.java
package grail.interfaces;

public interface Undoer {
	public void execute(UndoableCommandThread c);
	public void undo();
	public void redo();
	public void clear();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/vshapeinterface.java
package grail.interfaces;

import java.beans.PropertyChangeListener;

import util.annotations.Tags;

@Tags({"Angle", "move"})
public interface VShapeInterface extends Locatable{
	
	public RotatingLineInterface getLeftLine();
	public RotatingLineInterface getRightLine();
	
	public double getLinesLength();
	public void setLinesLength(double newLength);
	
	@Tags({"move"})
	public void move(int changeInX, int changeInY);
	
	void addPropertyChangeListenerToAtomics(PropertyChangeListener listener);
}
//END OF FILE
//START OF FILE: src/grail/interfaces/word.java
package grail.interfaces;
import util.annotations.Tags;

@Tags({"Word"})
public interface Word extends Token {
	public String getValue();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/mvc/bridgescenecontrollerinterface.java
package grail.interfaces.mvc;

import java.awt.event.KeyListener;
import java.awt.event.MouseListener;

import util.annotations.Tags;

@Tags({"BridgeSceneController"})
public interface BridgeSceneControllerInterface extends MouseListener, KeyListener {

}
//END OF FILE
//START OF FILE: src/grail/interfaces/mvc/commandinterpretercontrollerinterface.java
package grail.interfaces.mvc;

import java.awt.event.ActionListener;
import java.beans.PropertyChangeListener;

import javax.swing.JButton;
import javax.swing.JTextField;

import util.annotations.Tags;

@Tags({"CommandInterpreterController"})
public interface CommandInterpreterControllerInterface extends ActionListener, PropertyChangeListener{
	public JTextField getTextField();
	public JButton getSay();
	public JButton getPass();
	public JButton getFail();
	public JButton getApproach();
	
}
//END OF FILE
//START OF FILE: src/grail/interfaces/mvc/commandinterpreterviewinterface.java
package grail.interfaces.mvc;

import java.awt.event.ActionListener;
import java.beans.PropertyChangeListener;

import javax.swing.JButton;
import javax.swing.JTextField;

public interface CommandInterpreterViewInterface extends PropertyChangeListener {
	public void addControllerListener(ActionListener listener);
	public JTextField getTextField();
	public JButton getSay();
	public JButton getApproach();
	public JButton getFail();
	public JButton getPass();
}
//END OF FILE
//START OF FILE: src/grail/interfaces/mvc/delegatingbridgesceneviewinterface.java
package grail.interfaces.mvc;

import util.annotations.Tags;

@Tags({"DelegatingBridgeSceneView"})
public interface DelegatingBridgeSceneViewInterface {

}
//END OF FILE
//START OF FILE: src/grail/interfaces/mvc/paintlistener.java
package grail.interfaces.mvc;

import java.awt.Graphics2D;
import java.beans.PropertyChangeListener;

import util.annotations.Tags;

@Tags({"PaintListener"})
public interface PaintListener extends PropertyChangeListener{
	void paint(Graphics2D g);
}
//END OF FILE
//START OF FILE: src/grail/interfaces/mvc/paintingviewmaster.java
package grail.interfaces.mvc;

import util.annotations.Tags;

@Tags({"ObservableBridgeScenePainter"})
public interface PaintingViewMaster{
	public void addPaintListener(PaintListener listener);
	public void repaint();
}
//END OF FILE
//START OF FILE: src/grail/mvc/controller/bridgescenecontroller.java
package grail.mvc.controller;

import java.awt.Component;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;

import grail.SingletonsCreator;
import grail.interfaces.AvatarInterface;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.mvc.BridgeSceneControllerInterface;
import grail.interfaces.mvc.PaintingViewMaster;
import util.annotations.Tags;

@Tags({"BridgeSceneController"})
public class BridgeSceneController implements BridgeSceneControllerInterface{
	
	PaintingViewMaster painter;
	BridgeSceneInterface scene;
	
	private int lastClickX;
	private int lastClickY;
	private boolean clicked = false;	// to only respond to keys after click
	
	public BridgeSceneController(PaintingViewMaster painter){
		this.painter = painter;
		scene = SingletonsCreator.bridgeSceneFactoryMethod();
		((Component)painter).addKeyListener(this);
		((Component)painter).setFocusable(true);
		((Component)painter).addMouseListener(this);
	}

	@Override
	public void mouseClicked(MouseEvent e) {
		clicked = true;
		lastClickX = e.getX();
		lastClickY = e.getY();
	}
	
	@Override
	public void keyTyped(KeyEvent e) {
		// Do nothing if haven't clicked
		if (!clicked){
			return;
		}
		
		AvatarInterface knightToMove = null;
		switch (e.getKeyChar()){
		case 'a':
			knightToMove = scene.getArthur();
			break;
		case 'g':
			knightToMove = scene.getGalahad();
			break;
		case 'l':
			knightToMove = scene.getLancelot();
			break;
		case 'r':
			knightToMove = scene.getRobin();
			break;
		}
		
		if (knightToMove != null){
			knightToMove.setX(lastClickX);
			knightToMove.setY(lastClickY);
		}
	}
	
	
	
	/* Unused: */
	
	@Override
	public void mouseEntered(MouseEvent e) {}

	@Override
	public void mouseExited(MouseEvent e) {}

	@Override
	public void mousePressed(MouseEvent e) {}

	@Override
	public void mouseReleased(MouseEvent e) {}

	@Override
	public void keyPressed(KeyEvent e) {}

	@Override
	public void keyReleased(KeyEvent e) {}
}
//END OF FILE
//START OF FILE: src/grail/mvc/controller/commandinterpretercontroller.java
package grail.mvc.controller;

import java.awt.event.ActionEvent;
import java.beans.PropertyChangeEvent;

import javax.swing.JButton;
import javax.swing.JTextField;

import grail.SingletonsCreator;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandInterpreterInterface;
import grail.interfaces.mvc.CommandInterpreterViewInterface;
import grail.mvc.view.CommandInterpreterView;
import grail.interfaces.mvc.CommandInterpreterControllerInterface;
import util.annotations.PropertyNames;
import util.annotations.Tags;

@Tags({"CommandInterpreterController"})
@PropertyNames({"TextField", "Say", "Pass", "Fail", "Approach"})
public class CommandInterpreterController implements CommandInterpreterControllerInterface {
	
	public static final String SAY_TAG = "Say";
	public static final String APPROACH_TAG = "Approach";
	public static final String PASS_TAG = "Passed";
	public static final String FAIL_TAG = "Failed";
	
	private static final String MOVE_ARTHUR_LEFT_COMMAND = "move arthur - 20 0";
	private static final String MOVE_ARTHUR_RIGHT_COMMAND = "move arthur 20 0";
	private static final String SAY_COMMAND = "say \"Guess someone clicked a button\"";
	
	private CommandInterpreterInterface interpreter;
	private CommandInterpreterViewInterface uiFrame;
	private BridgeSceneInterface scene;
	
	private JTextField textField;
	private JButton sayButton;
	private JButton approachButton;
	private JButton failButton;
	private JButton passButton;
	
	public CommandInterpreterController(CommandInterpreterViewInterface frame){
		uiFrame = frame;
		frame.addControllerListener(this);
		
		textField = frame.getTextField();
		sayButton = frame.getSay();
		approachButton = frame.getApproach();
		failButton = frame.getFail();
		passButton = frame.getPass();
		
		interpreter = SingletonsCreator.commandInterpreterFactoryMethod();
		interpreter.addPropertyChangeListener(this);
		
		scene = SingletonsCreator.bridgeSceneFactoryMethod();
		scene.addPropertyChangeListener(this);
		
		//Set initial buttons settings
		sayButton.setEnabled(scene.preSay());
		approachButton.setEnabled(scene.preApproach());
		failButton.setEnabled(scene.preFailed());
		passButton.setEnabled(scene.prePassed());
	}

	@Override
	public JTextField getTextField(){
		return textField;
	}
	
	@Override
	public JButton getSay(){
		return sayButton;
	}
	
	@Override
	public JButton getPass(){
		return passButton;
	}
	
	@Override
	public JButton getFail(){
		return failButton;
	}
	
	@Override
	public JButton getApproach(){
		return approachButton;
	}
	
	@Override
	public void actionPerformed(ActionEvent event) {
		Object source =event.getSource();
		
		if (source == textField){
			interpreter.setCommand(event.getActionCommand());
			return;
			
		}else if (source == sayButton){
			interpreter.setCommand(SAY_COMMAND);
			
		}else if (source == approachButton){
			scene.approach(scene.getArthur());
			
		}else if (source == passButton){
			scene.passed();
			
		}else if (source == failButton){
			scene.failed();
			
		}else	if (CommandInterpreterView.MOVE_ARTHUR_LEFT.equals(event.getActionCommand())){
			interpreter.setCommand(MOVE_ARTHUR_LEFT_COMMAND);
		
		}else if (CommandInterpreterView.MOVE_ARTHUR_RIGHT.equals(event.getActionCommand())){
			interpreter.setCommand(MOVE_ARTHUR_RIGHT_COMMAND);
			
		}
	}

	@Override
	public void propertyChange(PropertyChangeEvent event) {
		String methodName = (String)(event.getOldValue());
		Object newValue= event.getNewValue();
		
		if (SAY_TAG.equalsIgnoreCase(methodName)){
			sayButton.setEnabled((Boolean)newValue);
			
		} else if (APPROACH_TAG.equalsIgnoreCase(methodName)){
			approachButton.setEnabled((Boolean)newValue);
			
		}else if (PASS_TAG.equalsIgnoreCase(methodName)){
			passButton.setEnabled((Boolean)newValue);
			
		}else if (FAIL_TAG.equalsIgnoreCase(methodName)){
			failButton.setEnabled((Boolean)newValue);
		}
	}


}
//END OF FILE
//START OF FILE: src/grail/mvc/view/avatarview.java
package grail.mvc.view;

import java.awt.Graphics2D;
import java.beans.PropertyChangeEvent;

import grail.interfaces.AvatarInterface;
import grail.interfaces.mvc.PaintListener;
import grail.interfaces.mvc.PaintingViewMaster;
import util.annotations.Tags;

@Tags({"PaintListener"})
public class AvatarView implements PaintListener{
	
	PaintingViewMaster painter;
	AvatarInterface avatar;
	
	public AvatarView(AvatarInterface avatar, PaintingViewMaster painter){
		this.painter = painter;
		this.avatar = avatar;
		
		avatar.addPropertyChangeListenerToAtomics(this);
	}

	@Override
	public void propertyChange(PropertyChangeEvent evt) {
		painter.repaint();
	}
	
	@Override
	public void paint(Graphics2D g){
		PaintingSupport.paintAvatar(g, avatar);
	}
}
//END OF FILE
//START OF FILE: src/grail/mvc/view/commandinterpreterview.java
package grail.mvc.view;

import java.awt.GridLayout;
import java.awt.event.ActionListener;
import java.beans.PropertyChangeEvent;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JTextField;

import grail.SingletonsCreator;
import grail.interfaces.CommandInterpreterInterface;
import grail.interfaces.mvc.CommandInterpreterViewInterface;
import util.annotations.PropertyNames;
import util.annotations.Tags;

@Tags({"CommandInterpreterView"})
@PropertyNames({"TextField", "ProgressBar", "Say", "Pass", "Fail", "Approach"})
public class CommandInterpreterView extends JFrame implements CommandInterpreterViewInterface{
	
	private static final int FRAME_ROWS = 4;
	private static final int FRAME_COLUMNS = 1;
	private static final int PANEL_ROWS = 1;
	private static final int PANEL_COLUMNS = 2;
	private static final String ERRORS_PROPERTY = "Errors";
	
	private static final int BUTTON_GRID_ROWS = 2;
	private static final int BUTTON_GRID_COLUMNS = 2;
	
	public static final String MOVE_ARTHUR_LEFT = "Move Arthur left";
	public static final String MOVE_ARTHUR_RIGHT = "Move Arthur right";
	public static final String SAY = "Say";
	public static final String APPROACH = "Approach";
	public static final String PASS = "Pass";
	public static final String FAIL = "Fail";
	
	private JLabel commandLabel;
	private JTextField commandField;
	
	private JMenuItem moveArthurLeft;
	private JButton moveArthurRight;
	
	private JTextField errorField;
	private JLabel errorLabel;
	
	private JButton sayButton;
	private JButton approachButton;
	private JButton failButton;
	private JButton passButton;
	
	private CommandInterpreterInterface interpreter;
	
	public CommandInterpreterView(){
		super("CommandInterpreter UI");
		
		interpreter = SingletonsCreator.commandInterpreterFactoryMethod();
		interpreter.addPropertyChangeListener(this);
		
		setLayout(new GridLayout(FRAME_ROWS, FRAME_COLUMNS));
		
		commandField = new JTextField("");
		commandLabel = new JLabel("Command:");
		JPanel commandPanel = new JPanel();
		commandPanel.setLayout(new GridLayout(PANEL_ROWS, PANEL_COLUMNS));
		commandPanel.add(commandLabel);
		commandPanel.add(commandField);
		
		errorField = new JTextField();
		errorField.setEditable(false);
		errorLabel = new JLabel("Errors:");
		JPanel errorPanel = new JPanel();
		errorPanel.setLayout(new GridLayout(PANEL_ROWS, PANEL_COLUMNS));
		errorPanel.add(errorLabel);
		errorPanel.add(errorField);
		
		moveArthurLeft = new JMenuItem(MOVE_ARTHUR_LEFT);
		JMenu menu = new JMenu("move");
		JMenuBar menuBar = new JMenuBar();
		menu.add(moveArthurLeft);
		menuBar.add(menu);
		
		moveArthurRight = new JButton(MOVE_ARTHUR_RIGHT);
		
		sayButton = new JButton(SAY);
		approachButton = new JButton(APPROACH);
		failButton = new JButton(FAIL);
		passButton = new JButton(PASS);
		
		JPanel buttonGrid = new JPanel();
		buttonGrid.setLayout(new GridLayout(BUTTON_GRID_ROWS, BUTTON_GRID_COLUMNS));
		buttonGrid.add(sayButton);
		buttonGrid.add(approachButton);
		buttonGrid.add(failButton);
		buttonGrid.add(passButton);
		
		
		setJMenuBar(menuBar);
		add(commandPanel);
		add(moveArthurRight);
		add(errorPanel);
		add(buttonGrid);
	}

	@Override
	public void addControllerListener(ActionListener listener) {
		commandField.addActionListener(listener);
		moveArthurLeft.addActionListener(listener);
		moveArthurRight.addActionListener(listener);
		sayButton.addActionListener(listener);
		approachButton.addActionListener(listener);
		failButton.addActionListener(listener);
		passButton.addActionListener(listener);
	}

	@Override
	public void propertyChange(PropertyChangeEvent event) {
		if (event.getPropertyName().equalsIgnoreCase(ERRORS_PROPERTY)){
			errorField.setText(interpreter.getErrors());
		}
	}
	
	@Override
	public JTextField getTextField(){
		return commandField;
	}
	
	@Override
	public JButton getSay(){
		return sayButton;
	}
	
	@Override
	public JButton getApproach(){
		return approachButton;
	}
	
	@Override
	public JButton getFail(){
		return failButton;
	}
	
	@Override
	public JButton getPass(){
		return passButton;
	}
}
//END OF FILE
//START OF FILE: src/grail/mvc/view/consolesceneview.java
package grail.mvc.view;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import grail.SingletonsCreator;
import grail.interfaces.BridgeSceneInterface;
import util.annotations.Tags;

@Tags({"ConsoleSceneView"})
public class ConsoleSceneView implements PropertyChangeListener{

	/**
	 * Constructor automatically registers this class as an observer of BridgeSceneInterface
	 */
	public ConsoleSceneView(){
		BridgeSceneInterface scene = SingletonsCreator.bridgeSceneFactoryMethod();
		
		// Register as listener of knights
		scene.getArthur().addPropertyChangeListenerToAtomics(this);
		scene.getGalahad().addPropertyChangeListenerToAtomics(this);
		scene.getGuard().addPropertyChangeListenerToAtomics(this);
		scene.getLancelot().addPropertyChangeListenerToAtomics(this);
		scene.getRobin().addPropertyChangeListenerToAtomics(this);
			
		SceneBackgroundView.registerAsListenerOfBackground(scene, this);
		
		scene.addPropertyChangeListener(this); // for assertion events
	}
	
	@Override
	public void propertyChange(PropertyChangeEvent evt) {
		System.out.println(evt);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/mvc/view/customswingtextfieldfactory.java
package grail.mvc.view;

import javax.swing.JTextField;

import bus.uigen.widgets.VirtualTextField;
import bus.uigen.widgets.swing.SwingTextFieldFactory;
import util.annotations.Tags;

/**
 * Used for object editor
 * @author
 *
 */
@Tags({"CustomSwingTextFieldFactory"})
public class CustomSwingTextFieldFactory extends SwingTextFieldFactory {
	
	@Override
	protected JTextField createJTextField(String text) {
		JTextField toReturn = new JTextField(text);
		toReturn.setBackground(java.awt.Color.GREEN);
		toReturn.setForeground(java.awt.Color.BLUE);
		return toReturn;
	}
}
//END OF FILE
//START OF FILE: src/grail/mvc/view/delegatingbridgesceneview.java
package grail.mvc.view;

import grail.SingletonsCreator;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.mvc.DelegatingBridgeSceneViewInterface;
import grail.interfaces.mvc.PaintingViewMaster;
import util.annotations.Tags;

@Tags({"DelegatingBridgeSceneView"})
public class DelegatingBridgeSceneView implements DelegatingBridgeSceneViewInterface{
	
	public DelegatingBridgeSceneView(BridgeSceneInterface scene){
		PaintingViewMaster painter = SingletonsCreator.observableBridgeScenePainterFactoryMethod();
		
		painter.addPaintListener(new AvatarView(scene.getArthur(), painter));
		painter.addPaintListener(new AvatarView(scene.getGalahad(), painter));
		painter.addPaintListener(new AvatarView(scene.getGuard(), painter));
		painter.addPaintListener(new AvatarView(scene.getLancelot(), painter));
		painter.addPaintListener(new AvatarView(scene.getRobin(), painter));
		
		painter.addPaintListener(new SceneBackgroundView(scene, painter));
	}
	
}
//END OF FILE
//START OF FILE: src/grail/mvc/view/observablebridgescenepainter.java
package grail.mvc.view;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.util.ArrayList;
import java.util.List;

import grail.interfaces.mvc.PaintListener;
import grail.interfaces.mvc.PaintingViewMaster;
import util.annotations.Tags;

@Tags({"ObservableBridgeScenePainter"})
public class ObservableBridgeScenePainter extends Component implements PaintingViewMaster{
	
	List<PaintListener> listeners;
	
	public ObservableBridgeScenePainter() {
		listeners = new ArrayList<PaintListener>();
		setFocusable(true);
	}
	
	@Override
	@Tags({"addPaintListener"})
	public void addPaintListener(PaintListener listener){
		listeners.add(listener);
	}
	
	@Override
	public void paint(Graphics g){
		super.paint(g);
		
		for (PaintListener listener : listeners){
			listener.paint((Graphics2D) g);
		}
	}
}
//END OF FILE
//START OF FILE: src/grail/mvc/view/paintingsupport.java
package grail.mvc.view;

import java.awt.Graphics2D;
import java.awt.Toolkit;

import grail.interfaces.AvatarInterface;
import grail.interfaces.BoundedShapeInterface;
import grail.interfaces.ImageInterface;
import grail.interfaces.RotatingLineInterface;
import grail.interfaces.StringShapeInterface;
import grail.interfaces.VShapeInterface;

public class PaintingSupport {
	
	public static void paintRectangle(Graphics2D g, BoundedShapeInterface shape){
		g.drawRect(shape.getX(), shape.getY(), shape.getWidth(), shape.getHeight());
	}
	
	public static void paintOval(Graphics2D g, BoundedShapeInterface shape){
		g.drawOval(shape.getX(), shape.getY(), shape.getWidth(), shape.getHeight());
	}
	
	public static void paintStringShape(Graphics2D g, StringShapeInterface shape){
		g.drawString(shape.getText(), shape.getX(), shape.getY());
	}
	
	public static void paintImage(Graphics2D g, ImageInterface shape){
		g.drawImage(Toolkit.getDefaultToolkit().getImage(shape.getImageFileName()),
				shape.getX(), shape.getY(), null);
	}
	
	public static void paintLine(Graphics2D g, RotatingLineInterface line){
		g.drawLine(line.getX(), line.getY(), line.getX() + line.getWidth(), line.getY()+line.getHeight());
	}
	
	public static void paintVShape(Graphics2D g, VShapeInterface shape){
		paintLine(g, shape.getLeftLine());
		paintLine(g, shape.getRightLine());
	}
	
	public static void paintAvatar(Graphics2D g, AvatarInterface avatar){
		paintImage(g, avatar.getHead());
		paintLine(g, avatar.getTorso());
		paintStringShape(g, avatar.getStringShape());
		paintVShape(g, avatar.getArms());
		paintVShape(g, avatar.getLegs());
	}
}
//END OF FILE
//START OF FILE: src/grail/mvc/view/scenebackgroundview.java
package grail.mvc.view;

import java.awt.Graphics2D;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.mvc.PaintListener;
import grail.interfaces.mvc.PaintingViewMaster;
import util.annotations.Tags;

@Tags({"PaintListener"})
public class SceneBackgroundView implements PaintListener{
	BridgeSceneInterface scene;
	PaintingViewMaster painter;
	
	public SceneBackgroundView(BridgeSceneInterface scene, PaintingViewMaster painter){
		this.scene = scene;
		this.painter = painter;
		
		// Register for gorge
		scene.getGorge().getBridge().addPropertyChangeListener(this);
		scene.getGorge().getLeftSide().addPropertyChangeListener(this);
		scene.getGorge().getRightSide().addPropertyChangeListener(this);
		
		scene.getGuardArea().addPropertyChangeListener(this);
		scene.getKnightArea().addPropertyChangeListener(this);
	}
	
	public static void registerAsListenerOfBackground(BridgeSceneInterface scene, PropertyChangeListener listener){	
		
		// Register for gorge
		scene.getGorge().getBridge().addPropertyChangeListener(listener);
		scene.getGorge().getLeftSide().addPropertyChangeListener(listener);
		scene.getGorge().getRightSide().addPropertyChangeListener(listener);
		
		scene.getGuardArea().addPropertyChangeListener(listener);
		scene.getKnightArea().addPropertyChangeListener(listener);
	}

	@Override
	public void propertyChange(PropertyChangeEvent evt) {
		painter.repaint();
	}

	@Override
	public void paint(Graphics2D g) {
		PaintingSupport.paintLine(g, scene.getGorge().getLeftSide());
		PaintingSupport.paintLine(g, scene.getGorge().getRightSide());
		PaintingSupport.paintRectangle(g, scene.getGorge().getBridge());
		PaintingSupport.paintOval(g, scene.getGuardArea());
		PaintingSupport.paintOval(g, scene.getKnightArea());
	}
	
	
}
//END OF FILE
//START OF FILE: src/grail/scanner/commandinterpreter.java
package grail.scanner;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.List;

import grail.SingletonsCreator;
import grail.animations.AnimatingCommand;
import grail.animations.SleepBasedAnimator;
import grail.animations.WaitBasedAnimator;
import grail.animations.ClapCommand;
import grail.animations.ClapLockstepCommand;
import grail.animations.fromJavaTeaching.ABroadcastingClearanceManager;
import grail.animations.fromJavaTeaching.BroadcastingClearanceManager;
import grail.interfaces.AnimatorInterface;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandInterpreterInterface;
import grail.interfaces.CommandThread;
import grail.interfaces.ScannerBeanInterface;
import grail.interfaces.Table;
import grail.interfaces.Undoer;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;
import grail.interfaces.ParserInterface;

@Tags({"CommandInterpreter", "SignedMoveCommandInterpreter", "ErrorResilientCommandInterpreter","ObservableCommandInterpreter"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Command", "Errors"})
@EditablePropertyNames({"Command"})
public class CommandInterpreter implements CommandInterpreterInterface {

	private List<PropertyChangeListener> listeners = new ArrayList<PropertyChangeListener>();
	
	// Key references
	private ScannerBeanInterface scannerBean;
	private BridgeSceneInterface scene;
	private ParserInterface parser;
	private BroadcastingClearanceManager clearanceManager;
	
	// Required table
	private Table avatars;
	
	// fields that back properties
	private String command ="";
	private String errorString = "";
	
	// Avatar-specific animators
	AnimatorInterface arthurAnimator = new SleepBasedAnimator();
	AnimatorInterface robinAnimator = new SleepBasedAnimator();
	AnimatorInterface galahadAnimator = new SleepBasedAnimator();
	AnimatorInterface lancelotAnimator = new SleepBasedAnimator();
	AnimatorInterface guardAnimator = new SleepBasedAnimator();
	
	// Lockstep animators
	AnimatorInterface arthurLockstepAnimator = new WaitBasedAnimator();
	AnimatorInterface robinLockstepAnimator = new WaitBasedAnimator();
	AnimatorInterface galahadLockstepAnimator = new WaitBasedAnimator();
	AnimatorInterface lancelotLockstepAnimator = new WaitBasedAnimator();
	
	// Constructor
	public CommandInterpreter(BridgeSceneInterface scene, ScannerBeanInterface scannerBean){
		this.scannerBean = scannerBean;
		this.scene = scene;
		parser = SingletonsCreator.parserFactoryMethod();
		avatars = SingletonsCreator.avatarTableFactoryMethod();
		clearanceManager = SingletonsCreator.broadcastingClearanceManagerMethod();
	}
	
	@Override
	public String getCommand(){
		return command;
	}
	
	@Override
	public void setCommand(String command){
		String oldCommand = this.command;
		this.command = command;
		parser.setCommandText(command);
		
		String oldErrorString = errorString;
		errorString = parser.getErrors();
		notifyAllListeners("Errors", oldErrorString, errorString);
		notifyAllListeners("Command", oldCommand, command);
		
		// Execute the command
		CommandThread commandThread = parser.getCommandObject();
		commandThread.run();
	}//end setCommand

	@Override
	public String getErrors() {
		return errorString;
	}

	@Override
	public void addPropertyChangeListener(PropertyChangeListener listener) {
		listeners.add(listener);
	}
	
	private void notifyAllListeners(String propertyName, Object oldValue, Object newValue){
		for (PropertyChangeListener listener : listeners){
			listener.propertyChange(new PropertyChangeEvent(this, propertyName, oldValue, newValue));
		}
	}

	@Override
	@Tags({"asynchronousArthur"})
	public void asynchronousArthur() {
		Thread thread = new Thread(new AnimatingCommand(arthurAnimator, scene.getArthur()));
		thread.start();
	}

	@Tags({"asynchronousGalahad"})
	@Override
	public void asynchronousGalahad() {
		Thread thread = new Thread(new AnimatingCommand(galahadAnimator, scene.getGalahad()));
		thread.start();
	}

	@Tags({"asynchronousLancelot"})
	@Override
	public void asynchronousLancelot() {
		Thread thread = new Thread(new AnimatingCommand(lancelotAnimator, scene.getLancelot()));
		thread.start();
	}

	@Override
	@Tags({"asynchronousRobin"})
	public void asynchronousRobin() {
		Thread thread = new Thread(new AnimatingCommand(robinAnimator, scene.getRobin()));
		thread.start();
	}
	
	@Override
	@Tags({"asynchronousGuard"})
	public void asynchronousGuard(){
		Thread thread = new Thread(new ClapCommand(guardAnimator, scene));
		thread.start();
	}
	
	@Override
	@Tags({"waitingArthur"})
	public void waitingArthur() {
		Thread thread = new Thread(new AnimatingCommand(arthurAnimator, scene.getArthur(), true));
		thread.start();
	}

	@Tags({"waitingGalahad"})
	@Override
	public void waitingGalahad() {
		Thread thread = new Thread(new AnimatingCommand(galahadAnimator, scene.getGalahad(), true));
		thread.start();
	}

	@Tags({"waitingLancelot"})
	@Override
	public void waitingLancelot() {
		Thread thread = new Thread(new AnimatingCommand(lancelotAnimator, scene.getLancelot(), true));
		thread.start();
	}

	@Override
	@Tags({"waitingRobin"})
	public void waitingRobin() {
		Thread thread = new Thread(new AnimatingCommand(robinAnimator, scene.getRobin(), true));
		thread.start();
	}
	
	@Tags({"startAnimation"})
	@Override
	public void startAnimation() {
		clearanceManager.proceedAll();
	}

	@Override
	public void lockstepArthur() {
		Thread thread = new Thread(new AnimatingCommand(arthurLockstepAnimator, scene.getArthur()));
		thread.start();
	}

	@Override
	public void lockstepGalahad() {
		Thread thread = new Thread(new AnimatingCommand(galahadLockstepAnimator, scene.getGalahad()));
		thread.start();
	}

	@Override
	public void lockstepLancelot() {
		Thread thread = new Thread(new AnimatingCommand(lancelotLockstepAnimator, scene.getLancelot()));
		thread.start();
	}

	@Override
	public void lockstepRobin() {
		Thread thread = new Thread(new AnimatingCommand(robinLockstepAnimator, scene.getRobin()));
		thread.start();
	}
	
	/**
	 * Moves any lockstep methods forward a step.
	 */
	@Override
	@Tags({"clapGuardLockstep"})
	public void lockstepGuard(){
		Thread thread = new Thread(new ClapLockstepCommand(guardAnimator, scene));
		thread.start();
	}
}
//END OF FILE
//START OF FILE: src/grail/scanner/parser.java
package grail.scanner;

import java.text.ParseException;
import java.util.HashSet;
import java.util.Set;

import grail.SingletonsCreator;
import grail.animations.fromJavaTeaching.BroadcastingClearanceManager;
import grail.collections.MyTable;
import grail.interfaces.AvatarInterface;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandThread;
import grail.interfaces.CompositeCommandThread;
import grail.interfaces.Number;
import grail.interfaces.ParserInterface;
import grail.interfaces.ScannerBeanInterface;
import grail.interfaces.Table;
import grail.interfaces.Token;
import grail.interfaces.UndoableCommandThread;
import grail.interfaces.Undoer;
import grail.interfaces.Word;
import grail.scanner.commands.ApproachCommand;
import grail.scanner.commands.CallCommand;
import grail.scanner.commands.CommandList;
import grail.scanner.commands.DefineCommand;
import grail.scanner.commands.ExecuteUndoableCommand;
import grail.scanner.commands.FailCommand;
import grail.scanner.commands.MoveCommand;
import grail.scanner.commands.PassCommand;
import grail.scanner.commands.ProceedAllCommand;
import grail.scanner.commands.RedoCommand;
import grail.scanner.commands.RepeatCommand;
import grail.scanner.commands.RotateLeftArmCommand;
import grail.scanner.commands.RotateRightArmCommand;
import grail.scanner.commands.SayCommand;
import grail.scanner.commands.SleepCommand;
import grail.scanner.commands.ThreadCommand;
import grail.scanner.commands.UndoCommand;
import grail.tokenBeans.EndToken;
import grail.tokenBeans.MinusToken;
import grail.tokenBeans.NumberToken;
import grail.tokenBeans.PlusToken;
import grail.tokenBeans.QuoteToken;
import grail.tokenBeans.StartToken;
import grail.tokenBeans.WordToken;
import grail.tokenBeans.commandBeans.ApproachCommandToken;
import grail.tokenBeans.commandBeans.FailCommandToken;
import grail.tokenBeans.commandBeans.MoveCommandToken;
import grail.tokenBeans.commandBeans.PassCommandToken;
import grail.tokenBeans.commandBeans.RepeatCommandToken;
import grail.tokenBeans.commandBeans.SayCommandToken;
import grail.tokenBeans.extraCommandBeans.CallCommandToken;
import grail.tokenBeans.extraCommandBeans.DefineCommandToken;
import grail.tokenBeans.extraCommandBeans.ProceedAllCommandToken;
import grail.tokenBeans.extraCommandBeans.RedoCommandToken;
import grail.tokenBeans.extraCommandBeans.RotateLeftArmCommandToken;
import grail.tokenBeans.extraCommandBeans.RotateRightArmCommandToken;
import grail.tokenBeans.extraCommandBeans.SleepCommandToken;
import grail.tokenBeans.extraCommandBeans.ThreadCommandToken;
import grail.tokenBeans.extraCommandBeans.UndoCommandToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.Tags;

@Tags({"Parser"})
@PropertyNames({"CommandText", "CommandObject", "Errors"})
@EditablePropertyNames({"CommandText"})
public class Parser implements ParserInterface {

	private static final String EOI = "end of input";
	private static final String QUOTE_TOKEN = "quoted string";
	private static final String COMMAND = "valid command";
	private static final String NUMBER_TOKEN = "integer";
	private static final String AVATAR_NAME = "avatar name";
	private static final String END_TOKEN = "end token (})";
	private static final String DEFINED_COMMAND_NAME = "defined command name";
	private static final String WORD_TOKEN = "word token";
	private static final String EMPTY_STRING = "";
	
	private ScannerBeanInterface scanner = SingletonsCreator.scannerFactoryMethod();
	private BridgeSceneInterface scene = SingletonsCreator.bridgeSceneFactoryMethod();
	private Table<AvatarInterface> avatars = SingletonsCreator.avatarTableFactoryMethod();
	private Table<CommandThread> routines = new MyTable<CommandThread>();
	private BroadcastingClearanceManager clearanceManager = SingletonsCreator.broadcastingClearanceManagerMethod();
	private Set<String> routineNames = new HashSet<String>();
	private Undoer undoer = SingletonsCreator.undoerFactoryMethod();
	
	// Property-backing fields
	private String commandText = "";
	private CommandThread commandObject;
	private String errorString = "";
	
	private Token[] tokens;
	private int tokenIndex;
	
	@Override
	public String getCommandText(){
		return commandText;
	}
	
	@Override
	public void setCommandText(String string){
		commandText = string;
		errorString = "";
		reset();

		try{
			scanner.setScannedString(string);
			tokens = scanner.getTokens();

			// parse into one command
			commandObject = parseCommand();
			
			// Make sure command has ended
			if (hasNext()){
				throw new ParsingException(next().getInput(), EOI);
			}
		}catch(ParsingException e){
			fillErrorString(e.getEncountered(), e.getExpected());
			
		}catch(ScanningException e){
			String[] errors = e.getErrors();
			errorString = "ERROR- Invalid tokens in command: " + errors[0];
			for (int i = 1; i < errors.length; ++i){
				errorString += (", " + errors[i]);
			}
			commandObject = null;
		}//end catch ScanningException
		
	}
	
	@Override
	public CommandThread getCommandObject(){
		return commandObject;
	}
	
	@Override
	public String getErrors(){
		return errorString;
	}
	
	private CommandThread parseCommand() throws ParsingException{
		
		if (!hasNext()){
			throw new ParsingException(EOI, COMMAND);
		}
		
		// Parse proper command based on first token
		Token currentToken = peek();
		
		if (currentToken instanceof SayCommandToken){
			return parseSayCommand();
			
		}else if (currentToken instanceof MoveCommandToken){
			UndoableCommandThread moveCommand = parseMoveCommand();
			return new ExecuteUndoableCommand(undoer, moveCommand);
			
		}else if (currentToken instanceof ApproachCommandToken){
			return parseApproachCommand();
			
		}else if (currentToken instanceof PassCommandToken){
			return parsePassCommand();
			
		}else if (currentToken instanceof FailCommandToken){
			return parseFailCommand();
			
		}else if (currentToken instanceof RepeatCommandToken){
			return parseRepeatCommand();
			
		}else if (currentToken instanceof StartToken){
			return parseCommandList();
			
		}else if (currentToken instanceof RotateLeftArmCommandToken){
			return parseRotateLeftArm();
			
		}else if (currentToken instanceof RotateRightArmCommandToken){
			return parseRotateRightArm();
			
		}else if (currentToken instanceof SleepCommandToken){
			return parseSleep();
			
		}else if (currentToken instanceof DefineCommandToken){
			return parseDefine();
			
		}else if (currentToken instanceof CallCommandToken){
			return parseCall();
			
		}else if (currentToken instanceof ThreadCommandToken){
			return parseThread();
			
		}else if (currentToken instanceof ProceedAllCommandToken){
			return parseProceedAll();
			
		}else if (currentToken instanceof UndoCommandToken){
			return parseUndo();
			
		}else if (currentToken instanceof RedoCommandToken){
			return parseRedo();
			
		}else {
			throw new ParsingException(currentToken.getInput(), COMMAND);
		}
	}
	
	@Tags({"parseProceedAllCommand"})
	private CommandThread parseProceedAll() {
		next();	//consume token
		
		return new ProceedAllCommand(clearanceManager);
	}
	
	@Tags({"parseRedoCommand"})
	private CommandThread parseRedo() {
		next();	//consume token
		
		return new RedoCommand(undoer);
	}
	
	@Tags({"parseUndoCommand"})
	private CommandThread parseUndo() {
		next();	//consume token
		
		return new UndoCommand(undoer);
	}
	
	@Tags({"parseThreadCommand"})
	private CommandThread parseThread() throws ParsingException {
		next(); 	//skip first token
		
		// Check for additional token
		if (!hasNext()){
			throw new ParsingException(EOI, DEFINED_COMMAND_NAME);
		}
		
		Token currentToken = next();
		String commandName;
		
		// Make sure token is a word
		if (currentToken instanceof Word){
			commandName = currentToken.getInput();
		
		}else {	
			throw new ParsingException(currentToken.getInput(), DEFINED_COMMAND_NAME);
		}
		
		if (!routineNames.contains(commandName)){
			throw new ParsingException(currentToken.getInput(), DEFINED_COMMAND_NAME);
		}
		
		return new ThreadCommand(commandName, routines);
	}

	@Tags({"parseCallCommand"})
	private CommandThread parseCall() throws ParsingException {
		next(); 	//skip first token
		
		// Check for additional token
		if (!hasNext()){
			throw new ParsingException(EOI, DEFINED_COMMAND_NAME);
		}
		
		Token currentToken = next();
		String commandName;
		
		// Make sure token is a word
		if (currentToken instanceof Word){
			commandName = currentToken.getInput();
		
		}else {	
			throw new ParsingException(currentToken.getInput(), DEFINED_COMMAND_NAME);
		}
		
		if (!routineNames.contains(commandName)){
			throw new ParsingException(currentToken.getInput(), DEFINED_COMMAND_NAME);
		}
		
		return new CallCommand(commandName, routines);
	}

	@Tags({"parseDefineCommand"})
	private CommandThread parseDefine() throws ParsingException {
		next(); 	//skip first token
		
		// Check for additional token
		if (!hasNext()){
			throw new ParsingException(EOI, WORD_TOKEN);
		}
		
		String commandName;
		Token currentToken = next();
		
		if (currentToken instanceof WordToken){
			commandName = currentToken.getInput();
			routineNames.add(commandName);
		
		} else{
			throw new ParsingException(EOI, WORD_TOKEN);
		}
		
		CommandThread command = parseCommand();
		
		return new DefineCommand(commandName, command, routines);
	}

	@Tags({"parseSleepCommand"})
	private CommandThread parseSleep() throws ParsingException {
		next(); 	//skip first token
		
		// Check for additional token
		if (!hasNext()){
			throw new ParsingException(EOI, NUMBER_TOKEN);
		}
		
		long sleepMilliseconds;
		Token currentToken = next();
		if (currentToken instanceof NumberToken){
			sleepMilliseconds = ((NumberToken) currentToken).getValue();
		}else{
			throw new ParsingException(currentToken.getInput(), NUMBER_TOKEN);
		}
		
		return new SleepCommand(sleepMilliseconds);
	}

	@Tags({"parseRotateRightArmCommand"})
	private CommandThread parseRotateRightArm() throws ParsingException {
		next(); 	//skip first token
		
		// Check for additional token
		if (!hasNext()){
			throw new ParsingException(EOI, AVATAR_NAME);
		}
		
		String avatarName;
		Token currentToken = next();

		// Make sure token is a word
		if (currentToken instanceof Word){
			avatarName = ((Word)currentToken).getValue();
		
		}else {	
			throw new ParsingException(currentToken.getInput(), AVATAR_NAME);
		}
		
		// Check that word is valid avatar name
		AvatarInterface avatar = (AvatarInterface)avatars.get(avatarName);
		if (null == avatar){
			throw new ParsingException(currentToken.getInput(), AVATAR_NAME);
		}
		
		int rotateDegrees = parseNumber();
		
		return new RotateRightArmCommand(avatar, rotateDegrees);
	}

	@Tags({"parseRotateLeftArmCommand"})
	private CommandThread parseRotateLeftArm() throws ParsingException {
		next(); 	//skip first token
		
		// Check for additional token
		if (!hasNext()){
			throw new ParsingException(EOI, AVATAR_NAME);
		}
		
		String avatarName;
		Token currentToken = next();

		// Make sure token is a word
		if (currentToken instanceof Word){
			avatarName = ((Word)currentToken).getValue();
		
		}else {	
			throw new ParsingException(currentToken.getInput(), AVATAR_NAME);
		}
		
		// Check that word is valid avatar name
		AvatarInterface avatar = (AvatarInterface)avatars.get(avatarName);
		if (null == avatar){
			throw new ParsingException(currentToken.getInput(), AVATAR_NAME);
		}
		
		int rotateDegrees = parseNumber();
		
		return new RotateLeftArmCommand(avatar, rotateDegrees);
	}

	/**
	 * Like the other helper methods, expects index to point to first token of command,
	 * and the first token to be correct.
	 * 
	 * @return SayCommand
	 * @throws ParsingException 
	 */
	private SayCommand parseSayCommand() throws ParsingException{
		
		next(); 	// skip the move token
		
		// Check for additional token
		if (!hasNext()){
			throw new ParsingException(EOI, QUOTE_TOKEN);
		}
		
		String quote;
		Token currentToken = next();	// grab the quote
		
		// Make sure it's a quote
		if (currentToken instanceof QuoteToken){
			quote = currentToken.getInput();
		
		}else {	
			throw new ParsingException(currentToken.getInput(), QUOTE_TOKEN);
		}
		
		return new SayCommand(scene, quote);
	}
	
	/**
	 * Like the other helper methods, expects index to point to first token of command,
	 * and the first token to be correct.
	 * 
	 * @return MoveCommand
	 * @throws ParsingException 
	 */
	private MoveCommand parseMoveCommand() throws ParsingException{
		next(); // Skip first token
		
		// The three things we need
		String avatarName;
		int moveX;
		int moveY;
		
		// Check for additional token
		if (!hasNext()){
			throw new ParsingException(EOI, AVATAR_NAME);
		}
		
		Token currentToken = next();
		
		// Make sure it's a word
		if (currentToken instanceof Word){
			avatarName = ((Word)currentToken).getValue();
		
		}else {	
			throw new ParsingException(currentToken.getInput(), AVATAR_NAME);
		}
		
		// Check that word is valid avatar name
		AvatarInterface avatar = (AvatarInterface)avatars.get(avatarName);
		if (null == avatar){
			throw new ParsingException(currentToken.getInput(), AVATAR_NAME);
		}
		
		moveX = parseNumber();
		moveY = parseNumber();
		
		return new MoveCommand(avatar, moveX, moveY);
	}
	
	/**
	 * Expects index to be pointing to first token of signed integer,
	 * and leaves it pointing just past the last token. Sets parsingError to
	 * true if there was an incorrect token (reports it itself in console).
	 * 
	 * @return parsed signed integer.
	 * @throws ParsingException 
	 */
	@Tags({"parseNumber"})
	private int parseNumber() throws ParsingException {

		int returnValue = 1;	// Must start at 1 to allow multiplication
		
		// Check for additional token
		if (!hasNext()){
			throw new ParsingException(EOI, NUMBER_TOKEN);
		}
		
		Token currentToken = next();
		
		// See if it's a sign
		if (currentToken instanceof PlusToken){

			// Check for additional token after sign
			if (!hasNext()){
				throw new ParsingException(EOI, NUMBER_TOKEN);
			}
			
			// No modifications necessary
			currentToken = next();
					
		} else if (currentToken instanceof MinusToken) {
			returnValue *= -1;
			
			// Check for additional token
			if (!hasNext()){
				throw new ParsingException(EOI, NUMBER_TOKEN);
			}
			
			currentToken = next();
		}

		// Grab the actual number
		if (currentToken instanceof NumberToken){
			returnValue *= ((Number)currentToken).getValue();
		
		}else{
			throw new ParsingException(currentToken.getInput(), NUMBER_TOKEN);
		}
		
		return returnValue;
	}
	
	/**
	 * Like the other helper methods, expects index to point to first token of command,
	 * and the first token to be correct.
	 * 
	 * @return ApproachCommand
	 * @throws ParsingException 
	 */
	private ApproachCommand parseApproachCommand() throws ParsingException{
		next(); 	// skip the first token
		
		// Check for additional token
		if (!hasNext()){
			throw new ParsingException(EOI, AVATAR_NAME);
		}
		
		Token currentToken = next();
		String avatarName;
		
		// Make sure it's a word
		if (currentToken instanceof Word){
			avatarName = ((Word)currentToken).getValue();
		
		}else {	
			throw new ParsingException(currentToken.getInput(), AVATAR_NAME);
		}
		
		// Check that word is valid avatar name
		AvatarInterface avatar = (AvatarInterface)avatars.get(avatarName);
		if (null == avatar){
			throw new ParsingException(currentToken.getInput(), AVATAR_NAME);
		}
		
		return new ApproachCommand(scene, avatar);
	}
	
	/**
	 * Like the other helper methods, expects index to point to first token of command,
	 * and the first token to be correct.
	 * 
	 * @return PassCommand
	 */
	private PassCommand parsePassCommand(){
		next(); 	// skip token
		return new PassCommand(scene);
	}
	
	/**
	 * Like the other helper methods, expects index to point to first token of command,
	 * and the first token to be correct.
	 * 
	 * @return FailCommand
	 */
	private FailCommand parseFailCommand(){
		next(); 	// skip token
		return new FailCommand(scene);
	}
	
	
	private CompositeCommandThread parseCommandList() throws ParsingException{
		next();	// Skip first token
		
		CompositeCommandThread commandList = new CommandList();
		
		while(hasNext() && !(peek() instanceof EndToken)){
			commandList.add(parseCommand());
		}
		
		// See if there is a closing bracket
		if (!hasNext()){
			throw new ParsingException(EOI, END_TOKEN);
		}
		
		Token currentToken = next();
		if (!(currentToken instanceof EndToken)){
			throw new ParsingException(currentToken.getInput(), END_TOKEN);
		}
		
		return commandList;
	}
	
	
	private RepeatCommand parseRepeatCommand() throws ParsingException{
		next();	// Skip first token
		
		// Check for additional token
		if (!hasNext()){
			throw new ParsingException(EOI, NUMBER_TOKEN);
		}
		
		Token currentToken = next();
		int numRepetitions = 0;
		
		if (currentToken instanceof NumberToken){
			numRepetitions = ((NumberToken) currentToken).getValue();
		
		}else{
			throw new ParsingException(currentToken.getInput(), NUMBER_TOKEN);
		}
			
		// Check for additional token
		if (!hasNext()){
			throw new ParsingException(EOI, COMMAND);
		}
		
		CommandThread command = parseCommand();
		
		return new RepeatCommand(numRepetitions, command);
	}
	
	private void fillErrorString(String encountered, String expected) {
		errorString = "ERROR- Encountered: " + encountered 
				+ " Expected: " + expected;
	}
	
	private Token next(){
		Token toReturn = tokens[tokenIndex];
		++tokenIndex;
		return toReturn;
	}
	private Token peek(){
		return tokens[tokenIndex];
	}
	
	private boolean hasNext(){
		return tokenIndex < tokens.length;
	}

	private void reset(){
		tokenIndex = 0;
	}
	
}
//END OF FILE
//START OF FILE: src/grail/scanner/parsingexception.java
package grail.scanner;

import java.io.IOException;
import java.text.ParseException;

import grail.interfaces.ParsingExceptionInterface;
import util.annotations.Tags;

@Tags({"ParsingException"})
public class ParsingException extends IOException implements ParsingExceptionInterface {

	private String expected;
	private String encountered;
	
	public ParsingException(String encountered, String expected){
		super("Encountered token not matched expected token");
		this.expected= expected;
		this.encountered = encountered;
	}
	
	@Override
	public String getExpected(){
		return expected;
	};
	@Override
	public String getEncountered(){
		return encountered;
	};
}
//END OF FILE
//START OF FILE: src/grail/scanner/scannerbean.java
package grail.scanner;

import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

import java.util.Iterator;

import grail.collections.ClearableHistory;
import grail.interfaces.ClearableHistoryInterface;
import grail.interfaces.ScannerBeanInterface;
import grail.interfaces.Token;
import grail.tokenBeans.EndToken;
import grail.tokenBeans.MinusToken;
import grail.tokenBeans.NumberToken;
import grail.tokenBeans.PlusToken;
import grail.tokenBeans.QuoteToken;
import grail.tokenBeans.StartToken;
import grail.tokenBeans.WordToken;
import grail.tokenBeans.commandBeans.ApproachCommandToken;
import grail.tokenBeans.commandBeans.FailCommandToken;
import grail.tokenBeans.commandBeans.MoveCommandToken;
import grail.tokenBeans.commandBeans.PassCommandToken;
import grail.tokenBeans.commandBeans.RepeatCommandToken;
import grail.tokenBeans.commandBeans.SayCommandToken;
import grail.tokenBeans.extraCommandBeans.CallCommandToken;
import grail.tokenBeans.extraCommandBeans.DefineCommandToken;
import grail.tokenBeans.extraCommandBeans.ProceedAllCommandToken;
import grail.tokenBeans.extraCommandBeans.RedoCommandToken;
import grail.tokenBeans.extraCommandBeans.RotateLeftArmCommandToken;
import grail.tokenBeans.extraCommandBeans.RotateRightArmCommandToken;
import grail.tokenBeans.extraCommandBeans.SleepCommandToken;
import grail.tokenBeans.extraCommandBeans.ThreadCommandToken;
import grail.tokenBeans.extraCommandBeans.UndoCommandToken;
import grail.tokenBeans.extraCommandBeans.WaitCommandToken;


/**
 * A "Bean" object whose setter for scannedString prints the tokens and their types.
 * @author Semion
 *
 */
@Tags({"ScannerBean"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"ScannedString", "Tokens", "Errors", "TokenList"})
@EditablePropertyNames({"ScannedString"})
public class ScannerBean implements ScannerBeanInterface{

	private String scannedString = "";
	
	private ClearableHistoryInterface tokenList = new ClearableHistory();
	
	private Token[] tokenStorage = new Token[100];
	private Token[] tokens = {};
	private int numTokens = 0;
	
	private String[] errorStorage = new String[100];
	private String[] errors = {};
	private int numErrors = 0;
	
	@Override
	public String getScannedString(){
		return scannedString;
	};
	
	@Override
	public void setScannedString(String s) throws ScanningException{
		scanString(s);
		scannedString = s;
	};
	
	@Override	
	public Token[] getTokens(){
		return tokens;
	}
	
	@Override
	public String[] getErrors(){
		return errors;
	}
	
	@Override
	public ClearableHistoryInterface getTokenList(){
		return tokenList;
	}
	
	/**
	 * Produces output from each string
	 * @throws ScanningException when invalid tokens are found. These are stored in "errors"
	 */
	private void scanString(String s) throws ScanningException{
		
		// Reset arrays
		numTokens = 0;
		numErrors = 0;
		tokenList.clear();
		
		Iterator<String> iterator = new ScanningIterator(s);
		
		Token tokenObject = null;	// used to grab each token
		
		// Take each space-delimited token
		while (iterator.hasNext()){
			String tokenString = iterator.next();

			boolean valid = true; // will be used to mark invalid tokens
			
			// Check for number
			if (Character.isDigit(tokenString.charAt(0))){
				valid = isValidNumber(tokenString);
				if (valid){
					tokenList.addElement(new NumberToken(tokenString));
					tokenObject = new NumberToken(tokenString);
				}
				
			// Check for word
			} else if (Character.isLetter(tokenString.charAt(0))){
				valid = isValidWord(tokenString);
				if (valid){
					tokenObject = constructCommandOrWord(tokenString);
				}
			
			// Check for quoted string
			} else if (tokenString.charAt(0) == '\"'){
				
				// The only invalid token would be an empty quoted string
				if (tokenString.length() <= "\"\"".length()){
					valid = false;
				}
				
				if (valid){
					
					// Trim quotation marks off the ends of the token
					tokenString = tokenString.substring(1, tokenString.length()-1);

					tokenList.addElement(new QuoteToken(tokenString));
					tokenObject = new QuoteToken(tokenString);
				}
			
			// Check for plus token
			} else if ("+".equals(tokenString)){
				tokenList.addElement(new PlusToken(tokenString));
				tokenObject = new PlusToken(tokenString);
			
			// Check for minus token
			} else if ("-".equals(tokenString)){
				tokenList.addElement(new MinusToken(tokenString));
				tokenObject = new MinusToken(tokenString);
			
			// Check for "start" token
			} else if ("{".equals(tokenString)){
				tokenList.addElement(new StartToken(tokenString));
				tokenObject = new StartToken(tokenString);
				
			// Check for "end" token
			} else if ("}".equals(tokenString)){
				tokenList.addElement(new EndToken(tokenString));
				tokenObject = new EndToken(tokenString);
				
			// Otherwise invalid
			} else{
				valid = false;
			}
			
			if (valid){
				tokenStorage[numTokens] = tokenObject;
				++numTokens;
			} else {
				errorStorage[numErrors] = tokenString;
				++numErrors;
			}
		}//end grabbing tokens
		
		// Compress arrays
		tokens = new Token[numTokens];
		for (int i = 0; i < numTokens; ++i){
			tokens[i] = tokenStorage[i];
		}
		
		errors = new String[numErrors];
		for (int i = 0; i < numErrors; ++i){
			errors[i] = errorStorage[i];
		}
		if (numErrors > 0){
			throw new ScanningException(errors);
		}
	}//end scanString()
	
	/**
	 * Constructs proper command from word, or just a word if no command matches.
	 * Assumes that word is non-empty and valid.
	 * From A6 onward, also stores a copy of the token in tokenList.
	 * 
	 * @param tokenString
	 * @return proper command object, or word object otherwise
	 */
	private Token constructCommandOrWord(String tokenString) {
		
		if ("approach".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new ApproachCommandToken(tokenString));
			return new ApproachCommandToken(tokenString);
			
		}else if ("fail".equalsIgnoreCase(tokenString)){

			tokenList.addElement(new FailCommandToken(tokenString));
			return new FailCommandToken(tokenString);
			
		}else if ("move".equalsIgnoreCase(tokenString)){

			tokenList.addElement(new MoveCommandToken(tokenString));
			return new MoveCommandToken(tokenString);
			
		}else if ("pass".equalsIgnoreCase(tokenString)){

			tokenList.addElement(new PassCommandToken(tokenString));
			return new PassCommandToken(tokenString);
			
		}else if ("repeat".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new RepeatCommandToken(tokenString));
			return new RepeatCommandToken(tokenString);
			
		}else if ("say".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new SayCommandToken(tokenString));
			return new SayCommandToken(tokenString);
			
		}else if ("call".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new CallCommandToken(tokenString));
			return new CallCommandToken(tokenString);
			
		}else if ("define".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new DefineCommandToken(tokenString));
			return new DefineCommandToken(tokenString);
			
		}else if ("proceedall".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new ProceedAllCommandToken(tokenString));
			return new ProceedAllCommandToken(tokenString);
			
		}else if ("redo".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new RedoCommandToken(tokenString));
			return new RedoCommandToken(tokenString);
			
		}else if ("rotateleftarm".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new RotateLeftArmCommandToken(tokenString));
			return new RotateLeftArmCommandToken(tokenString);
			
		}else if ("rotaterightarm".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new RotateRightArmCommandToken(tokenString));
			return new RotateRightArmCommandToken(tokenString);
			
		}else if ("sleep".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new SleepCommandToken(tokenString));
			return new SleepCommandToken(tokenString);
			
		}else if ("thread".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new ThreadCommandToken(tokenString));
			return new ThreadCommandToken(tokenString);
			
		}else if ("undo".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new UndoCommandToken(tokenString));
			return new UndoCommandToken(tokenString);
			
		}else if ("wait".equalsIgnoreCase(tokenString)){
			tokenList.addElement(new WaitCommandToken(tokenString));
			return new WaitCommandToken(tokenString);
		}
		
		// If none matched, return generic word
		tokenList.addElement(new WordToken(tokenString));
		return new WordToken(tokenString);
	}

	private static boolean isValidWord(String s){
		
		// Assume correct to begin with
		boolean validity = true;
		
		// Go through and stop at any invalid character
		for (int i = 0; i < s.length(); ++i){
			if (!Character.isLetter(s.charAt(i))){
				validity = false;
				break;
			}
		}
		return validity;
	}
	
	private static boolean isValidNumber(String s){
		
		// Assume correct to begin with
		boolean validity = true;
		
		// Go through and stop at any invalid character
		for (int i = 0; i < s.length(); ++i){
			if (!Character.isDigit(s.charAt(i))){
				validity = false;
				break;
			}
		}
		return validity;
	}
}//end class
//END OF FILE
//START OF FILE: src/grail/scanner/scanningexception.java
package grail.scanner;

import java.io.IOException;

import grail.interfaces.ScanningExceptionInterface;
import util.annotations.Tags;

@Tags({"ScanningException"})
public class ScanningException extends IOException implements ScanningExceptionInterface {

	private String[] errors;
	
	public ScanningException(String[] errors){
		super("Invalid tokens in scanned string");
		this.errors = errors;
	}
	
	@Override
	public String[] getErrors() {
		return errors;
	}
	
}
//END OF FILE
//START OF FILE: src/grail/scanner/scanningiterator.java
package grail.scanner;

import java.util.Iterator;

public class ScanningIterator implements Iterator<String>{

	private String stringData;
	private int position = 0;
	
	/**
	 * Constructor
	 * @param s string to iterate over
	 */
	public ScanningIterator(String s){
		stringData = s;
	}

	/**
	 * Checks whether there is another token to be had
	 */
	@Override
	public boolean hasNext() {
		
		// Consume spaces
		position = indexOfNot(stringData, ' ', position);
		if (position == -1){
			position = stringData.length();
		}
		return (position < stringData.length());
	}

	/**
	 * Gets the next token
	 */
	@Override
	public String next() {
		
		// Consume spaces
		position = indexOfNot(stringData, ' ', position);
		if (position == -1){
			
			// Rest of string was spaces
			position = stringData.length();
			return "";
		}
		
		// Get token
		int tokenStart = position;
		int tokenEnd = position;
		
		// Treat quoted strings differently
		if (stringData.charAt(tokenStart) == '\"'){
			
			// Look for the closing quote after this quote
			tokenEnd = indexOf(stringData, '\"', tokenStart + 1);
			
			if (tokenEnd == -1){
				System.out.println("ERROR: No closing quote found. Assumed line end to be closing quote.");
				tokenEnd = stringData.length();
				position = tokenEnd;
				return stringData.substring(tokenStart, tokenEnd)+ "\"";
			
			// If closing quote exists, make sure it is grabbed
			} else {
				++tokenEnd;
			}
			
		// If not a quoted string, end of token is a space or line end	
		} else {
			tokenEnd = indexOf(stringData, ' ', tokenStart);
		}
			
		if (tokenEnd == -1){
			tokenEnd = stringData.length();
		}
		
		position = tokenEnd;
		
		return stringData.substring(tokenStart, tokenEnd);
	}
	
	/**
	 * Returns index of first character equal to ch
	 * @param s
	 * @param ch
	 * @param fromIndex index at which to start search
	 * @return index of first ocurrence of ch after fromIndex, or -1 if not found
	 */
	private static int indexOf(String s, char ch, int fromIndex){
		for (int i=fromIndex; i < s.length(); ++i){
			if (s.charAt(i)==ch){
				return i;
			}
		}
		return -1;
	}

	/**
	 * Returns index of first character not equal to ch
	 * 
	 * @param s
	 * @param ch
	 * @param fromIndex index at which to start search
	 * @return index of first character that is not ch after fromIndex, or -1 if no non-ch characters found
	 */
	private static int indexOfNot(String s, char ch, int fromIndex){
		for (int i=fromIndex; i < s.length(); ++i){
			if (s.charAt(i)!=ch){
				return i;
			}
		}
		return -1;
	}

}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/approachcommand.java
package grail.scanner.commands;

import grail.interfaces.AvatarInterface;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandThread;
import util.annotations.Tags;

@Tags({"ApproachCommand"})
public class ApproachCommand implements CommandThread{

	private BridgeSceneInterface scene;
	private AvatarInterface avatar;
	
	public ApproachCommand(BridgeSceneInterface scene, AvatarInterface avatar){
		this.scene = scene;
		this.avatar = avatar;
	}
	
	@Override
	public void run() {
		scene.approach(avatar);
	}

}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/callcommand.java
package grail.scanner.commands;

import grail.SingletonsCreator;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandThread;
import grail.interfaces.Table;
import util.annotations.Tags;
import util.misc.ThreadSupport;

@Tags({"CallCommand"})
public class CallCommand implements CommandThread{

	private String name;
	private Table<CommandThread> environment;
	
	public CallCommand(String name, Table<CommandThread> environment){
		this.name = name;
		this.environment = SingletonsCreator.environmentFactoryMethod();
	}
	
	public CallCommand(String name){
		this (name, SingletonsCreator.environmentFactoryMethod());
	}
	
	@Override
	public void run() {
		CommandThread command = environment.get(name);
		command.run();
	}

}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/commandlist.java
package grail.scanner.commands;

import java.util.ArrayList;
import java.util.List;

import grail.interfaces.CompositeCommandThread;
import util.annotations.Tags;

@Tags({"CommandList"})
public class CommandList implements CompositeCommandThread{

	private List<Runnable> commands = new ArrayList<Runnable>();
	
	//Empty constructor
	public CommandList(){}

	@Override
	public void add(Runnable r) {
		commands.add(r);
	}
	
	@Override
	public void run() {
		for (Runnable command : commands){
			command.run();
		}
	}

}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/definecommand.java
package grail.scanner.commands;

import grail.SingletonsCreator;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandThread;
import grail.interfaces.Table;
import util.annotations.Tags;
import util.misc.ThreadSupport;

@Tags({"DefineCommand"})
public class DefineCommand implements CommandThread{

	private String name;
	private CommandThread body;
	private Table<CommandThread> environment;
	
	public DefineCommand(String name, CommandThread body, Table<CommandThread> environment){
		this.name = name;
		this.body = body;
		this.environment = SingletonsCreator.environmentFactoryMethod();
	}
	public DefineCommand(String name, CommandThread body){
		this(name, body, SingletonsCreator.environmentFactoryMethod());
	}
	
	@Override
	public void run() {
		environment.put(name, body);
	}

}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/executeundoablecommand.java
package grail.scanner.commands;

import grail.collections.MoveCommandUndoer;
import grail.interfaces.CommandThread;
import grail.interfaces.UndoableCommandThread;
import grail.interfaces.Undoer;

public class ExecuteUndoableCommand implements CommandThread {

	Undoer undoer;
	UndoableCommandThread moveCommand;
	
	public ExecuteUndoableCommand(Undoer undoer2, UndoableCommandThread moveCommand2){
		this.undoer = undoer2;
		this.moveCommand = moveCommand2;
	}
	
	@Override
	public void run() {
		undoer.execute(moveCommand);
	}

}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/failcommand.java
package grail.scanner.commands;

import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandThread;
import util.annotations.Tags;

@Tags({"FailCommand"})
public class FailCommand implements CommandThread{

	private BridgeSceneInterface scene;
	
	public FailCommand(BridgeSceneInterface scene){
		this.scene = scene;
	}
	
	@Override
	public void run() {
		scene.failed();
	}

}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/movecommand.java
package grail.scanner.commands;

import grail.interfaces.AvatarInterface;
import grail.interfaces.CommandThread;
import grail.interfaces.UndoableCommandThread;
import util.annotations.Tags;

@Tags({"MoveCommand"})
public class MoveCommand implements UndoableCommandThread{

	private AvatarInterface avatar;
	private int xOffset;
	private int yOffset;
	
	public MoveCommand(AvatarInterface avatar, int xOffset, int yOffset){
		this.avatar = avatar;
		this.xOffset = xOffset;
		this.yOffset = yOffset;
	}
	
	@Override
	public void run() {
		avatar.move(xOffset, yOffset);
	}

	@Override
	public void undo() {
		avatar.move(-xOffset, -yOffset);
	}

	
}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/passcommand.java
package grail.scanner.commands;

import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandThread;
import util.annotations.Tags;

@Tags({"PassCommand"})
public class PassCommand implements CommandThread{

	private BridgeSceneInterface scene;
	
	public PassCommand(BridgeSceneInterface scene){
		this.scene = scene;
	}
	
	@Override
	public void run() {
		scene.passed();
	}

}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/proceedallcommand.java
package grail.scanner.commands;

import grail.SingletonsCreator;
import grail.animations.fromJavaTeaching.BroadcastingClearanceManager;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandThread;
import util.annotations.Tags;
import util.misc.ThreadSupport;

@Tags({"ProceedAllCommand"})
public class ProceedAllCommand implements CommandThread{

	private BroadcastingClearanceManager clearanceManager;
	
	public ProceedAllCommand(BroadcastingClearanceManager clearanceManager){
		this.clearanceManager = SingletonsCreator.broadcastingClearanceManagerMethod();;
	}
	public ProceedAllCommand(){
		this.clearanceManager = SingletonsCreator.broadcastingClearanceManagerMethod();
	}
	
	@Override
	public void run() {
		clearanceManager.proceedAll();
	}

}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/redocommand.java
package grail.scanner.commands;

import grail.collections.MoveCommandUndoer;
import grail.interfaces.CommandThread;
import grail.interfaces.UndoableCommandThread;
import grail.interfaces.Undoer;
import util.annotations.Tags;

@Tags({"RedoCommand"})
public class RedoCommand implements CommandThread {

	Undoer undoer;
	
	public RedoCommand(Undoer undoer2){
		this.undoer = undoer2;
	}
	
	@Override
	public void run() {
		undoer.redo();
	}

}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/repeatcommand.java
package grail.scanner.commands;

import grail.interfaces.CommandThread;
import util.annotations.Tags;

@Tags({"RepeatCommand"})
public class RepeatCommand implements CommandThread{

	private int count;
	private CommandThread command;
	
	public RepeatCommand(int count, CommandThread command){
		this.count = count;
		this.command = command;
	}
	
	@Override
	public void run() {
		for (int i = 0; i < count; ++i){
			command.run();
		}
	}

}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/rotateleftarmcommand.java
package grail.scanner.commands;

import grail.interfaces.AvatarInterface;
import grail.interfaces.CommandThread;
import util.annotations.Tags;

@Tags({"RotateLeftArmCommand"})
public class RotateLeftArmCommand implements CommandThread {

	private int rotateDegrees;
	private AvatarInterface avatar;

	public RotateLeftArmCommand(AvatarInterface avatar, int rotateClockwiseDegrees){
		this.avatar = avatar;
		this.rotateDegrees = rotateClockwiseDegrees;
	}

	@Override
	public void run() {
		avatar.getArms().getLeftLine().rotateByClockwiseDegrees(rotateDegrees);
	}
}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/rotaterightarmcommand.java
package grail.scanner.commands;

import grail.interfaces.AvatarInterface;
import grail.interfaces.CommandThread;
import util.annotations.Tags;

@Tags({"RotateRightArmCommand"})
public class RotateRightArmCommand implements CommandThread {

	private int rotateDegrees;
	private AvatarInterface avatar;

	public RotateRightArmCommand(AvatarInterface avatar, int rotateClockwiseDegrees){
		this.avatar = avatar;
		this.rotateDegrees = rotateClockwiseDegrees;
	}

	@Override
	public void run() {
		avatar.getArms().getRightLine().rotateByClockwiseDegrees(rotateDegrees);
	}
}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/saycommand.java
package grail.scanner.commands;

import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandThread;
import util.annotations.Tags;

@Tags({"SayCommand"})
public class SayCommand implements CommandThread{

	private BridgeSceneInterface scene;
	private String quote;
	
	public SayCommand(BridgeSceneInterface scene, String quote){
		this.scene = scene;
		this.quote = quote;
	}
	
	@Override
	public void run() {
		scene.say(quote);
	}

}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/sleepcommand.java
package grail.scanner.commands;

import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandThread;
import util.annotations.Tags;
import util.misc.ThreadSupport;

@Tags({"SleepCommand"})
public class SleepCommand implements CommandThread{

	private long sleepTime;
	
	public SleepCommand(long sleepMilliseconds){
		this.sleepTime = sleepMilliseconds;
	}
	
	@Override
	public void run() {
		ThreadSupport.sleep(sleepTime);
	}

}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/threadcommand.java
package grail.scanner.commands;

import grail.SingletonsCreator;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandThread;
import grail.interfaces.Table;
import util.annotations.Tags;
import util.misc.ThreadSupport;

/**
 * Does not call command if such a command does not exist
 *
 */
@Tags({"ThreadCommand"})
public class ThreadCommand implements CommandThread{

	private String name;
	private Table<CommandThread> environment;
	
	public ThreadCommand(String name, Table<CommandThread> environment){
		this.name = name;
		this.environment = SingletonsCreator.environmentFactoryMethod();
	}
	public ThreadCommand(String name){
		this (name, SingletonsCreator.environmentFactoryMethod());
	}
	
	
	@Override
	public void run() {
		CommandThread command = environment.get(name);
		Thread thread = new Thread(command);
		thread.start();
	}

}
//END OF FILE
//START OF FILE: src/grail/scanner/commands/undocommand.java
package grail.scanner.commands;

import grail.collections.MoveCommandUndoer;
import grail.interfaces.CommandThread;
import grail.interfaces.UndoableCommandThread;
import grail.interfaces.Undoer;
import util.annotations.Tags;
@Tags({"UndoCommand"})
public class UndoCommand implements CommandThread {

	Undoer undoer;
	
	public UndoCommand(Undoer undoer2){
		this.undoer = undoer2;
	}
	
	@Override
	public void run() {
		undoer.undo();
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/endtoken.java
package grail.tokenBeans;

import util.annotations.EditablePropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"End"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@EditablePropertyNames({"Input"})
public class EndToken extends GenericToken {

	public EndToken(String input){
		super(input);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/generictoken.java
package grail.tokenBeans;

import grail.interfaces.Token;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;


@Tags({"Token"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input"})
@EditablePropertyNames({"Input"})
public abstract class GenericToken implements Token{
	private String input;
		
	public GenericToken(String input){
		setInput(input);
	}
	
	@Override
	public void setInput(String newString) {
		input = newString;
	}

	@Override
	public String getInput() {
		return input;
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/minustoken.java
package grail.tokenBeans;

import util.annotations.EditablePropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Minus"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@EditablePropertyNames({"Input"})
public class MinusToken extends GenericToken {

	public MinusToken(String input){
		super(input);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/numbertoken.java
package grail.tokenBeans;

import grail.interfaces.Number;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Number"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class NumberToken extends GenericToken implements Number{
	
	private int value;
	
	public NumberToken(String input){
		super(input);
		value = Integer.parseInt(input);
	}
	
	@Override
	public void setInput(String newString) {
		super.setInput(newString);
		value = Integer.parseInt(newString);
	}

	@Override
	public int getValue() {
		return value;
	}
}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/plustoken.java
package grail.tokenBeans;

import util.annotations.EditablePropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Plus"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@EditablePropertyNames({"Input"})
public class PlusToken extends GenericToken {

	public PlusToken(String input){
		super(input);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/quotetoken.java
package grail.tokenBeans;

import util.annotations.EditablePropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Quote"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@EditablePropertyNames({"Input"})
public class QuoteToken extends GenericToken{

	public QuoteToken(String input){
		super(input);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/starttoken.java
package grail.tokenBeans;

import util.annotations.EditablePropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Start"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@EditablePropertyNames({"Input"})
public class StartToken extends GenericToken{
	
	public StartToken(String input){
		super(input);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/wordtoken.java
package grail.tokenBeans;

import grail.interfaces.Word;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Word"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class WordToken extends GenericToken implements Word{

	private String value;
	
	public WordToken(String input){
		super(input);
		value = input.toLowerCase();
	}
	
	@Override
	public void setInput(String newString) {
		super.setInput(newString);
		value = newString.toLowerCase();
	}

	@Override
	public String getValue() {
		return value;
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/commandbeans/approachcommandtoken.java
package grail.tokenBeans.commandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Approach"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class ApproachCommandToken extends WordToken {

	public ApproachCommandToken(String input) {
		super(input);
	}
	
}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/commandbeans/failcommandtoken.java
package grail.tokenBeans.commandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Fail"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class FailCommandToken extends WordToken {

	public FailCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/commandbeans/movecommandtoken.java
package grail.tokenBeans.commandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Move"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class MoveCommandToken extends WordToken {

	public MoveCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/commandbeans/passcommandtoken.java
package grail.tokenBeans.commandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Pass"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class PassCommandToken extends WordToken {

	public PassCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/commandbeans/repeatcommandtoken.java
package grail.tokenBeans.commandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Repeat"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class RepeatCommandToken extends WordToken {

	public RepeatCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/commandbeans/saycommandtoken.java
package grail.tokenBeans.commandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Say"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class SayCommandToken extends WordToken {

	public SayCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/callcommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Call"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class CallCommandToken extends WordToken {

	public CallCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/definecommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Define"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class DefineCommandToken extends WordToken {

	public DefineCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/proceedallcommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"ProceedAll"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class ProceedAllCommandToken extends WordToken {

	public ProceedAllCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/redocommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Redo"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class RedoCommandToken extends WordToken {

	public RedoCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/rotateleftarmcommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"RotateLeftArm"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class RotateLeftArmCommandToken extends WordToken {

	public RotateLeftArmCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/rotaterightarmcommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"RotateRightArm"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class RotateRightArmCommandToken extends WordToken {

	public RotateRightArmCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/sleepcommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Sleep"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class SleepCommandToken extends WordToken {

	public SleepCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/threadcommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Thread"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class ThreadCommandToken extends WordToken {

	public ThreadCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/undocommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Undo"})
@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class UndoCommandToken extends WordToken {

	public UndoCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/grail/tokenbeans/extracommandbeans/waitcommandtoken.java
package grail.tokenBeans.extraCommandBeans;

import grail.tokenBeans.WordToken;
import util.annotations.EditablePropertyNames;
import util.annotations.PropertyNames;
import util.annotations.StructurePattern;
import util.annotations.StructurePatternNames;
import util.annotations.Tags;

@Tags({"Wait"})@StructurePattern(StructurePatternNames.BEAN_PATTERN)
@PropertyNames({"Input", "Value"})
@EditablePropertyNames({"Input"})
public class WaitCommandToken extends WordToken {

	public WaitCommandToken(String input) {
		super(input);
	}

}
//END OF FILE
//START OF FILE: src/main/assignment12.java
package main;

import java.awt.Component;
import javax.swing.JFrame;
import javax.swing.JProgressBar;

import bus.uigen.OEFrame;
import bus.uigen.ObjectEditor;
import grail.SingletonsCreator;
import grail.animations.fromJavaTeaching.BroadcastingClearanceManager;
import grail.interfaces.BridgeSceneInterface;
import grail.interfaces.CommandInterpreterInterface;
import grail.interfaces.mvc.DelegatingBridgeSceneViewInterface;
import grail.interfaces.mvc.PaintingViewMaster;
import grail.mvc.view.CustomSwingTextFieldFactory;
import util.annotations.Tags;
import util.misc.ThreadSupport;

@Tags({"ProgressBarCreator"})
public class Assignment12 {

		private static JProgressBar progressBar;
		private static final int BAR_ROWS = 1;
		private static final int BAR_COLUMNS = 1;
		private static final int BAR_WIDTH = 500;
		private static final int BAR_HEIGHT = 100;
		
		private static final int PROGRESS_BAR_MAX = 100;
		private static final int BAR_INCREMENT = 25;
		
		private static final int SCENE_VIEW_WIDTH = 1500;
		private static final int SCENE_VIEW_HEIGHT = 500;
		
		private static final int LOCKSTEP_CLAPS = 30;
		
		private static final String[] COMMAND_LIST = {
				"move aRThur 50 0",
				"moVE arthur - 30 - 50",
				"UnDO",
				"ReDo",
				"approach arthur", 
				"{ say \"Hello!\" sleep 1000 say \"Howdy\" sleep 1000 pass }",
				"{ approach galahad }",
				"define rotate { rotateLeftArm galahad - 6 rotateRightArm guard 6 }",
				"define together { say \"one\" call rotate sleep 1000 say \"two\" call rotate }",
				"define routine { repeat 10 { call together sleep 1000 } }",
				"call routine"
		};

		
		public static void main(String[] args) throws InterruptedException {
			
			ObjectEditor.initialize();
			bus.uigen.widgets.TextFieldSelector.setTextFieldFactory(new CustomSwingTextFieldFactory());
			
			// Model
			BridgeSceneInterface scene = SingletonsCreator.bridgeSceneFactoryMethod();
			
			// Painting view
			DelegatingBridgeSceneViewInterface sceneView = SingletonsCreator.delegatingBridgeSceneViewFactoryMethod();
			PaintingViewMaster sceneViewComponent = SingletonsCreator.observableBridgeScenePainterFactoryMethod();
			
			JFrame sceneFrame = new JFrame("Bridge Scene");
			sceneFrame.add((Component)sceneViewComponent);
			sceneFrame.setSize(SCENE_VIEW_WIDTH, SCENE_VIEW_HEIGHT);
			sceneFrame.setVisible(true);
			
			
			//Clearance manager
			BroadcastingClearanceManager clearanceManager = SingletonsCreator.broadcastingClearanceManagerMethod();
			OEFrame clearanceManagerFrame = ObjectEditor.edit(clearanceManager);
			
			
			// Command Interpreter:
			// Model
			CommandInterpreterInterface commandInterpreter = SingletonsCreator.commandInterpreterFactoryMethod();
			
			// View
			OEFrame interpreterFrame = ObjectEditor.edit(commandInterpreter);
			
			// Demo of waiting methods
			commandInterpreter.waitingArthur();
			commandInterpreter.waitingGalahad();
			commandInterpreter.waitingRobin();
			commandInterpreter.waitingLancelot();
			
			clearanceManager.waitForProceed();
			
			for (int i = 0; i < COMMAND_LIST.length; ++i){
				clearanceManager.waitForProceed();
				commandInterpreter.setCommand(COMMAND_LIST[i]);
			}
			
			// Demo of lockstep methods: has to come after the others
			// because it makes threads proceed
			commandInterpreter.lockstepArthur();
			for (int i = 0; i < LOCKSTEP_CLAPS; ++i){
				commandInterpreter.lockstepGuard();
			}
		}//end main
		
		public static JProgressBar getProgressBar(){
			return progressBar;
		}
}//end class
//END OF FILE
//START OF FILE: src/main/runtests12semion.java
package main;

import gradingTools.comp401f16.assignment12.testcases.Assignment12Suite;


public class RunTests12Semion {
	public static void main (String[] args) {
		Assignment12Suite.main(args);
	}

}
//END OF FILE
